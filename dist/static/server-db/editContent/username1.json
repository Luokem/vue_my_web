{"data":[{"editContent":"开始啦","id":1,"date":"2018-07-10T08:32:09.370Z"},{"editContent":"开始啦","id":2,"date":"2018-07-10T08:33:14.678Z"},{"editContent":"我要学后端","id":3,"date":"2018-07-10T08:54:32.972Z"},{"editContent":"<body>\n<div class=\"f\">\n    <div class=\"s\"></div>\n  </div>\n</body>\n <style>\n    .f {\n      width: 500px;\n      height: 300px;\n      background: red;\n    }\n\n    .s {\n      width: 300px;\n      height: 100px;\n      background: gray;\n    }\n\n    /*  第一种方法　：.s类的margin*/\n    /*.f {\n      border: 1px solid white;\n    }\n     .s {\n      margin-top: 100px;\n      margin-left: 100px;\n     }*/\n\n\n    /* 第二种方法：　用．f的：padding,因为后面的padding增加，对应减少width,和height */\n    /*.f {\n      height: 200px;\n      padding-top: 100px;\n      width: 400px;\n      padding-left: 100px;\n    }*/\n\n\n    /* 第三种方法．用.s　的定位*/\n  /*.f {\n    position: relative;\n  }\n  .s {\n    position: absolute;\n    top: 100px;\n    left: 100px;\n  }*/\n /*\n    第四种方法，用.f用display: flex\n  */\n  .f{\n    display:  flex;\n    align-items:  center;\n    justify-content:  center;\n  }\n\n/*\n注意，这里用table, table-cell,vertical-align,效果时.s填满.f\n*/\n  </style>\n","id":4,"date":"2018-07-10T13:39:52.619Z"},{"editContent":"在标签都加载完了就开始执行里面代码","id":5,"date":"2018-07-10T14:10:06.742Z"},{"editContent":"\n    <script type=\"text/javascript\">\n\n    // 兼容低版本ie浏览器的代码,对于现代浏览器可以省略部分代码\n    function createXHR(){\n      if (typeof XMLHttpRequest != \"undefined\"){\n        return new XMLHttpRequest();\n      } else if (typeof ActiveXObject != \"undefined\"){\n        if (typeof arguments.callee.activeXString != \"string\"){\n          var versions = [ \"MSXML2.XMLHttp.6.0\", \"MSXML2.XMLHttp.3.0\",\n          \"MSXML2.XMLHttp\"], i, len;\n          for (i=0,len=versions.length; i < len; i++){\n            try {\n              new ActiveXObject(versions[i]);\n              arguments.callee.activeXString = versions[i];\n              break;\n            } catch (ex){\n              //跳过\n            }\n          }\n        }\n        return new ActiveXObject(arguments.callee.activeXString);\n      } else {\n        throw new Error(\"No XHR object available.\");\n      }\n    }\n/*\n前面部分也可以改成这样\n  var xp;\n\t\tif(XMLHttpRequest) {\n\t\t\txp = new XMLHttpRequest();\n\t\t} else {\n\t\t\txp = new ActiveXObject(\"Microsoft.XMLHTTP\");\n\t\t} \n*/\n\n\n    //1. 需要创建一个可以发送Ajax的对象\n    var xhr =  createXHR();\n\n    //2.调用open发送，准备发送一次请求！！！\n    xhr.open(\"get\", \"/index?name=lisi&age=10\", true);\n\n\n\n    //4. 准备接收服务端发来的数据\n    //.  此部分代码必须要放在send之前，确保可以立刻响应服务端的数据\n    xhr.onreadystatechange = function () {\n      //只等待状态为4的\n      if (xhr.readyState === 4){\n\n        //判断是成功的状态\n        if (xhr.status >= 200 && xhr.status < 300 ){\n          //成功是，打印服务的响应数据\n          console.log(xhr.response);\n        }\n      }\n    };\n\n    //3. 调用send方法，发送一次HTTP请求\n    //.send的参数可以为空，但是必须要写\n    xhr.send();\n\n    console.log(\"after ajax send ....\");\n\n    </script>","id":6,"date":"2018-07-10T14:21:44.744Z"},{"editContent":"<style>\t\n/*项目直接用,引用的目录要注意*/\n@font-face{\n\t\tfont-family: time;\n\t\tsrc: url(../css/fzpy.ttf.TTF);\n\t\t}\n</style>","id":7,"date":"2018-07-10T14:31:41.740Z"},{"editContent":"<script> \n// 兼容低版本ie浏览器的代码,对于现代浏览器可以省略部分代码\n    function createXHR(){\n      if (typeof XMLHttpRequest != \"undefined\"){\n        return new XMLHttpRequest();\n      } else if (typeof ActiveXObject != \"undefined\"){\n        if (typeof arguments.callee.activeXString != \"string\"){\n          var versions = [ \"MSXML2.XMLHttp.6.0\", \"MSXML2.XMLHttp.3.0\",\n          \"MSXML2.XMLHttp\"], i, len;\n          for (i=0,len=versions.length; i < len; i++){\n            try {\n              new ActiveXObject(versions[i]);\n              arguments.callee.activeXString = versions[i];\n              break;\n            } catch (ex){\n              //跳过\n            }\n          }\n        }\n        return new ActiveXObject(arguments.callee.activeXString);\n      } else {\n        throw new Error(\"No XHR object available.\");\n      }\n    }\n\n   \n        //3. 调用send方法，发送一次HTTP请求\n        //发送post请求时，send方法要填写数据了\n\n        var data = \"name=\" + user + \"&passwd=\" + passwd + \"&gender=\" + gender;\n        xhr.send(data);\n/*\n 这里注意的是post请求方法要以键=值形式\n*/\n</script>","id":8,"date":"2018-07-10T14:42:30.874Z"},{"editContent":"$(\"#**\").append(\"<div></div>\");\ndocument.querySelector('body').appendChild(\"<script></script>\") //往后面添加","id":9,"date":"2018-07-10T15:13:23.655Z"},{"editContent":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>边框应用三</title>\n    <style media=\"screen\">\n      * {\n        margin: 0;\n        padding: 0;\n      }\n\n      body {\n        background: #F7F7F7;\n      }\n\n      .wrapper {\n        width: 1200px;\n        margin: 0 auto;\n        box-sizing: border-box;\n        padding: 20px;\n      }\n\n      .header {\n        padding: 20px 0;\n        text-align: center;\n      }\n      .header h2 {\n        font-size: 30px;\n        line-height: 1.2;\n        font-weight: normal;\n      }\n\n      .main::before,\n      .main::after {\n        content: \"\";\n        display: block;\n        height: 0;\n        clear: both;\n        overflow: hidden;\n      }\n\n      .main .item {\n        float: left;\n        display: flex; \n        width: 210px;\n        height: 210px;\n        margin: 0 30px  30px;\n        background: #FFF;\n        box-shadow: 2px 2px 8px gray;\n        position: relative;\n      }\n\n      .main .item::before {\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        line-height: 210px; /*让文字居中显示*/\n        text-align: center;\n        content: attr(data-brief);/*内容为属性的值*/\n        color: #FFF;\n        transition: all 0.5s ease-in;\n        z-index: -1;/*先不显示，当hover时在显示文字*/\n      }\n\n      .main .item:hover::before {\n        background-color: gray;\n        opacity: 0.5;\n        z-index: 100;\n      }\n\n      .item .border-radius {\n        width: 180px;\n        height: 180px;\n        border: 1px solid red;\n        margin: auto;\n      }\n\n      .item:nth-child(1) .border-radius {\n        border-radius: 90px;\n      }\n\n      .item:nth-child(2) .border-radius {\n        border-radius: 90px 90px 0 0;\n      }\n\n      .item:nth-child(3) .border-radius {\n        height: 90px;\n        border-radius: 90px 90px 0 0;\n      }\n\n      .item:nth-child(4) .border-radius {\n        border-radius: 90px 0 0 0;\n      }\n\n      .item:nth-child(5) .border-radius {\n        width: 90px;\n        height: 90px;\n        border-radius: 90px 0 0 0;\n      }\n\n      .item:nth-child(6) .border-radius {\n        height: 90px;\n        border-radius: 90px/45px;\n      }\n\n      .item:nth-child(7) .border-radius {\n        width: 90px;\n        border-radius: 45px/90px;\n      }\n\n      .item:nth-child(8) .border-radius {\n        height: 45px;\n        border-radius: 90px  90px 0 0 / 45px 45px 0 0;\n      }\n\n      .item:nth-child(9) .border-radius {\n        width: 45px;\n        border-radius: 45px 0 0 45px / 90px 0 0 90px;\n      }\n\n      .item:nth-child(10) .border-radius {\n        width: 45px;\n        height: 90px;\n        border-radius: 45px 0 0 0px / 90px 0 0 0;\n      }\n\n      .item:nth-child(11) .border-radius {\n        width: 40px;\n        height: 40px;\n        border: 70px solid red;\n        border-radius: 90px;\n      }\n\n      .item:nth-child(12) .border-radius {\n        width: 40px;\n        height: 40px;\n        border: 70px solid red;\n        border-radius: 50px;\n      }\n\n      .item:nth-child(13) .border-radius {\n        width: 40px;\n        height: 40px;\n        border: 70px solid red;\n        border-radius: 90px 0 0 0;\n      }\n\n      .item:nth-child(14) .border-radius {\n        width: 40px;\n        height: 40px;\n        border: 70px solid red;\n        border-radius: 90px 0 90px 0;\n      }\n\n      .item:nth-child(15) .border-radius {\n        width: 0;\n        height: 0;\n        border: 90px solid red;\n        border-color: red blue green yellow;\n      }\n\n      .item:nth-child(16) .border-radius {\n        width: 0;\n        height: 0;\n        border: 90px solid red;\n        border-color: red  #FFF green yellow;\n      }\n\n      .item:nth-child(17) .border-radius {\n        width: 0px;\n        height: 0px;\n        border: 90px solid red;\n        border-radius: 90px;\n        border-right-color: transparent;/*右边框直接为完全透明*/\n      }\n\n      .item:nth-child(18) .border-radius {\n        width: 0px;\n        height: 0px;\n        border: 90px solid  transparent;\n        border-radius: 90px;\n        border-right-color: red;\n      }\n\n      .item:nth-child(19) .border-radius {\n        width: 180px;\n        height: 0px;\n        border-top-width: 90px;\n        border-bottom-width: 90px;\n        border-style: solid;\n        border-top-color: red;\n        border-bottom-color: green;\n        border-radius: 90px;\n      }\n\n      .item:nth-child(20) .border-radius {\n        width: 180px;\n        height: 90px;\n        border-bottom-width: 90px;\n        border-bottom-color: green;\n        border-radius: 90px;\n        background: red;\n      }\n\n      .item:nth-child(21) .border-radius {\n        width: 180px;\n        height: 90px;\n        border-bottom-width: 90px;\n        border-bottom-color: green;\n        border-radius: 90px;\n        background: red;\n        position: relative;\n      }\n\n      .item:nth-child(21) .border-radius::before,\n      .item:nth-child(21) .border-radius::after {\n         content: '';\n         display: block;\n         width: 20px;\n         height: 20px;\n         position: absolute;\n         border-width: 35px;\n         border-style: solid;\n         top: 50%;\n         border-radius: 45px;\n      }\n\n      .item:nth-child(21) .border-radius::before {\n        background-color: red;\n        border-color: green;\n      }\n\n      .item:nth-child(21) .border-radius::after{\n        background-color: green;\n        border-color: red;\n        right: 0;\n      }\n\n      .item:nth-child(22) .border-radius {\n        width: 160px;\n        height: 90px;\n        background: red;\n        border-radius: 10px;\n        position: relative;\n      }\n\n      .item:nth-child(22) .border-radius::before {\n        content: \"\";\n        display: block;\n        width: 0;\n        height: 0;\n        border-width: 10px;\n        border-style: solid;\n        border-color: transparent;\n        border-right-color: red;\n        position: absolute;\n        top: 16px;\n        left: -20px;\n      }\n\n      .item:nth-child(23) .border-radius {\n        width: 40px;\n        height: 40px;\n        border-width: 40px 0 40px 80px;\n        border-radius: 0 0 60px 0;\n      }\n\n      .item:nth-child(24) .border-radius {\n        width: 90px;\n        height: 40px;\n        border-width: 40px  20px  40px  80px;\n        border-radius: 40px  70px  70px 40px;\n      }\n\n      .item:nth-child(25) .border-radius {\n        width: 160px;\n        height: 80px;\n        background: red;\n        border-radius: 10px;\n        position: relative;\n      }\n\n      .item:nth-child(25) .border-radius::before {\n        position: absolute;\n        content: \"\";\n        display: block;\n        width: 30px;\n        height: 30px;\n        border-style: solid;\n        border-color: red;\n\n        /*出现对话形状，用下边框，左边框就可以\n        对下边框做圆角操作即可\n        */\n        border-width: 0 0 40px 70px;\n        border-radius: 0 0 60px 0;\n        right: -20px;\n        top: 0px;\n      }\n\n      .item:nth-child(26) .border-radius {\n        width: 180px;\n        height: 90px;\n        border-radius: 50%; /* border-radius: 90px/45px; 等价*/\n        /*百分比是宽度的百分比*/\n      }\n\n\n    </style>\n  </head>\n  <body>\n    <div class=\"wrapper\">\n      <div class=\"header\">\n        <h2>CSS 边框应用</h2>\n      </div>\n\n      <div class=\"main\">\n        <div class=\"item\" data-brief=\"正圆\">\n          <div class=\"border-radius\"></div>\n        </div>\n\n        <div class=\"item\" data-brief=\"拱形\">\n          <div class=\"border-radius\"></div>\n        </div>\n\n        <div class=\"item\" data-brief=\"半圆\">\n          <div class=\"border-radius\"></div>\n        </div>\n\n        <div class=\"item\" data-brief=\"左上角\">\n          <div class=\"border-radius\"></div>\n        </div>\n\n        <div class=\"item\" data-brief=\"四分之一\">\n          <div class=\"border-radius\"></div>\n        </div>\n\n        <div class=\"item\" data-brief=\"椭圆一\">\n          <div class=\"border-radius\"></div>\n        </div>\n\n        <div class=\"item\" data-brief=\"椭圆二\">\n          <div class=\"border-radius\"></div>\n        </div>\n\n        <div class=\"item\" data-brief=\"半个椭圆一\">\n          <div class=\"border-radius\"></div>\n        </div>\n\n        <div class=\"item\" data-brief=\"半个椭圆二\">\n          <div class=\"border-radius\"></div>\n        </div>\n\n        <div class=\"item\" data-brief=\"四分之一椭圆\">\n          <div class=\"border-radius\"></div>\n        </div>\n\n        <div class=\"item\" data-brief=\"圆环\">\n          <div class=\"border-radius\"></div>\n        </div>\n\n        <div class=\"item\" data-brief=\"方环\">\n          <div class=\"border-radius\"></div>\n        </div>\n\n        <div class=\"item\" data-brief=\"左上角圆饼\">\n          <div class=\"border-radius\"></div>\n        </div>\n\n        <div class=\"item\" data-brief=\"对角圆饼\">\n          <div class=\"border-radius\"></div>\n        </div>\n\n        <div class=\"item\" data-brief=\"四边颜色\">\n          <div class=\"border-radius\"></div>\n        </div>\n\n        <div class=\"item\" data-brief=\"三边颜色\">\n          <div class=\"border-radius\"></div>\n        </div>\n\n        <div class=\"item\" data-brief=\"四分之三圆饼\">\n          <div class=\"border-radius\"></div>\n        </div>\n\n        <div class=\"item\" data-brief=\"四分之一圆饼\">\n          <div class=\"border-radius\"></div>\n        </div>\n\n        <div class=\"item\" data-brief=\"阴阳一\">\n          <div class=\"border-radius\"></div>\n        </div>\n\n        <div class=\"item\" data-brief=\"阴阳二\">\n          <div class=\"border-radius\"></div>\n        </div>\n\n        <div class=\"item\" data-brief=\"八卦一\">\n          <div class=\"border-radius\"></div>\n        </div>\n\n        <div class=\"item\" data-brief=\"消息\">\n          <div class=\"border-radius\"></div>\n        </div>\n\n        <div class=\"item\" data-brief=\"乱七八糟形状\">\n          <div class=\"border-radius\"></div>\n        </div>\n\n        <div class=\"item\" data-brief=\"乱七八糟形状二\">\n          <div class=\"border-radius\"></div>\n        </div>\n\n        <div class=\"item\" data-brief=\"对话\">\n          <div class=\"border-radius\"></div>\n        </div>\n\n        <div class=\"item\" data-brief=\"使用百分比\">\n          <div class=\"border-radius\"></div>\n        </div>\n\n      </div>\n    </div>\n\n  </body>\n</html>\n","id":10,"date":"2018-07-10T15:16:28.270Z"},{"editContent":"<style>\n/*\n  闹钟时针和分针转动\n*/\n    .min {\n    width: 4px;\n    height: 60px;\n    background: black;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%,-100%);\n    transform-origin: bottom center;\n    opacity: .7;\n    animation: run 3600s linear infinite;\n  }\n\n  .sec {\n    width: 2px;\n    height: 60px;\n    background: red;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform-origin: center bottom;\n    transform: translate(-50%, -100%);\n\n    animation: run 60s steps(60)   infinite;\n}\n\n@keyframes run {\n  0% {\n    transform: translate(-50%, -100%) rotate(0deg);\n  }\n  100% {\n    transform: translate(-50%,-100%) rotate(360deg);\n  }\n}\n</style>","id":11,"date":"2018-07-11T03:09:08.350Z"},{"editContent":"transform：  translate(10px,20px) , rotate(40deg),scale(1.5)","id":12,"date":"2018-07-11T03:29:08.907Z"},{"editContent":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>滚动图片</title>\n  <style>\n    * {\n      margin: 0;\n      padding: 0;\n    }\n\n    .box {\n      margin: 50px auto;\n      width: 882px;\n      height: 86px;\n      border: 1px solid black;\n      overflow: hidden;\n\n    }\n   /*\n   在广告栏放多了一倍的图片，动画是到100%时播放到长度一半，暂停动画用效果是hover的时候用animation-play-state: paused;\n*/\n    ul {\n      list-style: none;\n      width: 1774px;\n      height: 100%;\n\n      animation: roll 10s linear infinite;\n\n    }\n\n    ul:hover {\n      animation-play-state: paused;\n    }\n\n    .box li {\n      float: left;\n\n    }\n\n    @keyframes roll {\n      0% {}\n\n      100%  {\n\n        transform: translate(-50% );\n      }\n    }\n  </style>\n</head>\n<body>\n  <div class=\"box\">\n    <ul>\n      <li><img src=\"./image/1.jpg\" alt=\"\"></li>\n      <li><img src=\"./image/2.jpg\" alt=\"\"></li>\n      <li><img src=\"./image/3.jpg\" alt=\"\"></li>\n      <li><img src=\"./image/4.jpg\" alt=\"\"></li>\n      <li><img src=\"./image/5.jpg\" alt=\"\"></li>\n      <li><img src=\"./image/6.jpg\" alt=\"\"></li>\n      <li><img src=\"./image/7.jpg\" alt=\"\"></li>\n    \n      <li><img src=\"./image/1.jpg\" alt=\"\"></li>\n      <li><img src=\"./image/2.jpg\" alt=\"\"></li>\n      <li><img src=\"./image/3.jpg\" alt=\"\"></li>\n      <li><img src=\"./image/4.jpg\" alt=\"\"></li>\n      <li><img src=\"./image/5.jpg\" alt=\"\"></li>\n      <li><img src=\"./image/6.jpg\" alt=\"\"></li>\n      <li><img src=\"./image/7.jpg\" alt=\"\"></li>\n\n    </ul>\n  </div>\n</body>\n</html>\n","id":13,"date":"2018-07-11T03:32:46.701Z"},{"editContent":"/*\nswitch根据不同的条件执行不同的动作。括号里面的值和case值匹配执行里面代码,有bread;就不执行下一个case\n*/\n\n\n   switch (m) {\n     case 12:\n     sum += 30;\n     case 11:\n     sum += 30;\n     case 10:\n     sum += 31;\n     case 9:\n     sum += 31;\n     case 8:\n     sum += 31;\n     case 7:\n     sum += 30;\n     case 6:\n     sum += 31;\n     case 5:\n     sum += 30;\n     case 4:\n     sum += 31;\n     case 3:\n     sum = sum+leaf+28;\n     case 2:\n     sum += 31;\n     case 1:\n     sum += d;\n   }\n","id":14,"date":"2018-07-11T04:11:41.686Z"},{"editContent":" <script>\n    /*\n   用for循环进行阶乘，类似递归函数求和了\n*/\n    var a =1;\n    var sum=0;\n    for(var i=1; i<=10;i++)\n    {\n      a=a*i;\n      console.log(a);\n      sum +=a;\n      console.log(sum)\n    }\n    console.log(a);\n    console.log(sum);\n\n  /*\n   递归函数：  缺点， 调用栈， 从左到右堆放，算出了一个高峰值，在进行下一个调用， 容易栈溢出，花时间也长\n*/\nfunction g (n){\n\tif(n <=0){\n\t\treturn  n = 1\n\t}else {\n\t\treturn n* g(n-1)\n\t}\n}\n\n/*\n尾递归:   线性的，没有栈溢出问题，花时间也少。n是循环变量，m是循环要返回结果\n*/\nfunction gg (n,m=1){\n\tif(n <=0){\n\t\treturn m\n\t}else {\n\t\treturn g(n-1,n*m)\n\t}\n}\nconsole.time(gg(50))\n\n  </script>","id":15,"date":"2018-07-11T05:12:47.097Z"},{"editContent":"<script>\n  /*    push  后面最后一个添加   pop后面最后一个删除  unshift  往第一个添加  shift 删除第一个  join按照分隔符变成字符串    sort 按照ascii码排序(数字，字母都可以，数字前字母后)     slice(1,3)  复制   splice(index,1)  删除\n*/\n\n//注意sort ， 默认是按ascii， 自己也可以写个函数作为规则\n\nfunction compareFunction(a, b) {\n    console.log(\"a = \" + a + \"  b = \" + b);\n    // return a - b;\n\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\nvar e = [10, 20, 3, 4, 22];\n\n  e.sort(compareFunction);\n  console.log(e);\n/*  控制台输出\nVM798:6 a = 10  b = 20\nVM798:6 a = 20  b = 3\nVM798:6 a = 10  b = 3\nVM798:6 a = 20  b = 4\nVM798:6 a = 10  b = 4\nVM798:6 a = 3  b = 4\nVM798:6 a = 20  b = 22\nVM798:20 (5) [3, 4, 10, 20, 22]\n*/\n</script>","id":16,"date":"2018-07-11T09:08:51.172Z"},{"editContent":"push,  unshift, shift, splice,  join,  sort ,slice, forEach(elem,index,array), map,  filter,  indexOf, reduce\n\nlodash的map,remove, orderBy类似数组map, filter,  sort","id":17,"date":"2018-07-11T12:58:40.888Z"},{"editContent":"chartAt,   charCodeAt,  fromChartCode, split,  toLowerCase, toUpperCase  , match, replace, slice ,  substring,  indexOf, trim","id":18,"date":"2018-07-12T02:58:13.211Z"},{"editContent":"<script>\n    /*\n      功能:　随机生成包含数字和字母的6位验证码\n      @len: 生成位数\n      */\n    function random(len) {\n      var strings = \"\";\n\n      for(var i=0; i<len; i++) {\n        var num = Math.floor(Math.random() * 75 + 48);\n        if (((num >= 48) && (num <=\n          57)) || ((num >= 65) && (num <=\n          90)) || ((num >= 97) && (num <=\n          122))) {\n        var strings =strings + String.fromCharCode(num);\n      }\n      else{\n        i--;\n      }\n\n    }\n    return strings;\n  }\n\n  var ret =  random(6);\n  console.log(ret);\n  </script>","id":19,"date":"2018-07-12T03:15:46.419Z"},{"editContent":"<script>\n    方法名字都是一样。.focus(), .blur()\n</script>","id":20,"date":"2018-07-12T06:23:54.632Z"},{"editContent":"<style>  \n@media all and (orientation: portrait) {\n        .four::after {\n          content: \"竖屏\"；\n        }\n      }\n\n      @media all and (orientation:landscape) {\n        .four::after {\n          content: \"横屏\" ;\n        }\n      }\n\n</style>\n","id":21,"date":"2018-07-12T06:55:06.063Z"},{"editContent":"onload  页面节点，图片，外部脚本，加载完，同步代码执行完后才运行\n$(document).ready() 和$(function(){}) 是页面的节点标签加完了就执行。","id":22,"date":"2018-07-12T07:23:43.729Z"},{"editContent":".siblings():找到匹配元素的同胞元素的集合，括号如有参数就是再筛选一次制定元素。\n\nnext():  找到匹配元素的直接同胞元素集合\n\nfind:  匹配元素的子元素","id":23,"date":"2018-07-12T08:19:22.543Z"},{"editContent":"对于HTML元素本身就带有的固有属性，在处理时，使用prop方法。\n对于HTML元素我们自己自定义的DOM属性，在处理时，使用attr方法(prop来获取时会返回undefined)。","id":24,"date":"2018-07-12T08:29:14.660Z"},{"editContent":"<script>\n/*\n先了解：  简单类型： String,  Number, Boolean,  Undefined,引用类型：Function, Object;  \n简单类型存放再栈内存中， 引用类型存放在堆内存中\n\n浅拷贝和深拷贝通常指对象复制。\n\n浅拷贝:  只是简单复制了内存的指针，并没有开辟新的内存空间，一个改了就会让另一个对象改变。\n\n深拷贝是开辟了新的内存空间，产生了新的对象， 一个改变了不会改变另一个。\n\n数组里面第一层是简单类型，用.slice()  , concat 是深拷贝， 如有引用类型就是浅拷贝。\n\n进行浅拷贝的方法：  直接赋值；  遍历赋值； 数组有引用类型情况下.slice , concat 方法；  jquery的$.extend(false, a被拷贝对象, b对象)； \n*/\n深拷贝方法: 主要考虑是简单类型就直接复制，对于对象的，就判断是数组还是对象再遍历。 \n  遍历对象， 递归函数调用;   JSON.string和JSON.parse  忽略了原型链的关系,该方法会忽略掉值为 undefined 的属性以及函数表达式，但不会忽略值为 null 的属性。;  jquery的$.extend(true, a被拷贝对象, b);Object.assign(b,...,a被拷贝对象),该方法会跳过那些值为 null 或 undefined 的源对象;  Lodash的库.cloneDeep(a被拷贝对象);  immutable库\nconst { Map } = require('immutable')\nconst map1 = Map({ a: 1, b: 2, c: 3 })\nconst map2 = map1.set('b', 50)\nmap1.get('b') // 2\nmap2.get('b') // 50   \n\n/*\n1 递归实现深拷贝\n*/\n\nfunction deepCopy (initObj, endObj) {\nconst obj = endObj || {};\n\nfor(let i in initObj) {\n  var prop = initalObj[i]; // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况\n  if(prop === obj) {\n    continue;\n  }     \n\n  if(typeof initObj[i] == 'object') {\n    obj[i] = (initObj[i].constructor === Array) ? [] : {};\n    arguments.callee(initObj[i], obj[i]); //包含当前执行函数,用于递归调用\n  }\n  else {\n    obj[i] = initObj[i];\n  }\n}\nreturn obj;\n}\n\nvar a = {};\nvar obj1 = {\"name\": \"lisi\", \"age\": 1, \"arr\": [1, 2, 3]};\nvar obj2 = deepCopy(obj1, a);\nobj2.arr = [3, 4,5];\nconsole.log(obj1);  //对象obj2.arr改变数据,但obj1.arr=[1,2,3] ,说明深拷贝成功\n</script>","id":25,"date":"2018-07-12T15:30:53.543Z"},{"editContent":"with(), height()是获得匹配第一个元素的高度，  或者设置匹配元素的每一个高度。\n\n.innerHeight(),  .innerWidth() 是不包括border\nouterHeight()  包括border","id":26,"date":"2018-07-12T23:08:59.421Z"},{"editContent":"offset()  相对于当前文档的坐标， 可以获取或者设置.offset(left, top)。\n\npostion() 相对于最近已定位的父元素的坐标。可以获取或者设置.\n\nscrollTop或者scrollLeft() 是指滚动条滚动的长度。","id":27,"date":"2018-07-12T23:24:04.598Z"},{"editContent":"添加节点操作，有一个特点， 语法上不一样，但实现了同样的功能.\nappend,  appendTo  是往匹配元素的内部最后面添加。append前面参数是位置，  后面是内容。 appendTo前面是内容， 后面是位置.\n\nbefore,  innerBefore往匹配元素前面添加\nafter, innerAfter  往匹配元素的后面添加\n\nwrap  wrapInner,  wrapAll   包裹","id":28,"date":"2018-07-12T23:44:39.201Z"},{"editContent":"remove, 从DOM中删除\nempty,  删除匹配元素里面的dom\ndetach,  从dom删除，但保留了数据。","id":29,"date":"2018-07-12T23:47:25.816Z"},{"editContent":"属性:   attr,  prop,   removeAttr, removeProp\ncss： addClass,  removeClass,  css,  hasClass\n尺寸:  height, width,  innerHeight, innerWidth,  outerHeight, outerWidth\n位置:  offset,  position,   scrollLeft, scrollTop\nDOM节点添加:   append, appendTo,  before,  innerBefore,  after, innerAfter, wrap,  wrapInner\nDOM删除: remove,  empty,  detach\n获取设置Dom内容： html, text, val\n鼠标事件：click  , contentmenu,  dbclick  , mouseover, mouseout\n键盘事件, keydown,  keyup, keypress\n表单事件： change,  submit,  focus,  blur\n效果： show, hide,  fadeIn  fadeOut   fadeToggle  slideDown  slideUp  slideToggle  animate","id":30,"date":"2018-07-13T00:04:38.671Z"},{"editContent":"首先，讲原型链继承，要先讲什么是原型链， 再讲继承\n访问对象的属性的时候， 先从对象的基本属性找， 找不到再从隐形原型__proto__往上来找，这就是原型链。\n从原型链找到方法和属性就是原型链继承。\n判断是不是自己的属性可以用.hasOwnProperty来判断，而hasOwnProperty其实是继承Object.prototype原型.\n\n原型灵活性， 可以自由添加和修改， 后面生成对象会继承下来。就像Jquery一开始是从{}开始，慢慢从jquery.prototype添加属性。还有Vue.prototype.axios  = axios, 后面的小组件.vue就可以直接用了this.axios\n\n\n以下从新梳理开始理解：\n一.\n老朋友: typeof  判断类型\n\"一切皆对象\" ： 对象是属性和方法集合。 所有东西都由对象来继承和所有东西都可以用对象来表达。\n\n二.\n老朋友: 原型prototype\n对象的属性prototype的constructor可以找到函数本身。（谁拥有这个prototype）\n\n每个对象都有隐性原型__proto__，  __proto__引用创建了该对象的函数的prototype\n\n最终所有对象.prototype指向 Object.prototype  ， 继承了里面很多属性和方法.\n而Object.prototype的__proto__是null\n\ninstanceof  来判断过程引出了继承关系.  --继承--原型链\ninstanceof表示的就是一种继承关系\n\n同时也有一个特别地方, 就是function Function()  {}  ， Function是创建了Object,  String, Number,等其他数据类型.\nFunction 的__proto__ 是 Function.prototype,  而Function.prototype的__proto__指向Object.prototype\nObject.__proto__指向Function.prototype.   这里形成了一个闭环.\n\n\n\n","id":31,"date":"2018-07-13T05:02:58.619Z"},{"editContent":"javascript在执行一个代码段之前，都会进行这些“准备工作”来生成执行上下文。这个“代码段”其实分三种情况——全局代码，函数体，eval代码。\n\n 变量、函数表达式——变量声明，默认赋值为undefined；\nthis——赋值；\n函数声明——赋值；\n这三种数据的准备情况我们称之为“执行上下文”或者“执行上下文环境”。\n\n函数每被调用一次，都会产生一个新的执行上下文环境.\n\n函数在定义的时候（不是调用的时候），就已经确定了函数体内部自由变量的作用域\n\n讲完了上下文环境，又来了新的问题——在执行js代码时，会有数不清的函数调用次数，会产生许多个上下文环境。这么多上下文环境该如何管理，以及如何销毁而释放内存呢？下一节将通过“执行上下文栈”来解释这个问题。\n\n","id":32,"date":"2018-07-13T07:14:26.203Z"},{"editContent":"        //var obj = { a: 10, b: 20 };\n        //var arr = [5, 'x', true];\n​\n        var obj = new Object();\n        obj.a = 10;\n        obj.b = 20;\n​\n        var arr = new Array();\n        arr[0] = 5;\n        arr[1] = 'x';\n        arr[2] = true;","id":33,"date":"2018-07-13T07:14:58.091Z"},{"editContent":"需求：\n1.  本函数要返回一个Promise对象\n2.  一个函数里面，要实现异步读取4个文件，后面3个文件读取数据完后逻辑处理要基于第一个文件读取数据。（因为是异步，所以并排一起readFile, 就无法得到到第一个文件内容，数据只能是外面声明赋值好的否则为undefined,  如果后面3个文件嵌套在第一个文件里里面返回函数， 代码看起来很臃肿，同时也无法判断该什么时候函数返回resolve ）\n\n解决方法:\n1.  新建一个模块，本函数传递4个路径过去给新模块\n2.  新模块新建一个方法a,统一都异步读取文件,使用Promise对象\n3   新模块新建一个方法b, 也是返回一个Promise对象给提出的需求的该函数，方法b 调用4次方法a, 路径当参数，使用Promise.all方法来处理4个文件返回的  Promise对象","id":34,"date":1531549688939},{"editContent":"aa","id":35,"date":1531552500384},{"editContent":"//---之前在nodejs有个需求，读取4个文件，当读取第一个文件数据后，才进行逻辑运算 ,  不过nodejs没Worder 对象\n<script>\n    /*\n     **.html文件\n  */\n    //一旦线程创建成功，那么线程立刻开始运行！！！\n    var one = new Worker(\"./one.js\");\n    var two = new Worker(\"./one.js\");\n    var three = new Worker(\"./for.js\");\n    var four = new Worker(\"./error.js\");\n\n\n    four.onerror = function (event) {\n      console.log(\"four: \", event.message);\n      four.terminate();\n    };\n\n    //postMessage方法，用于给线程发送数据\n    one.postMessage(100);\n    two.postMessage(110);\n\n    //接收子线程发来的数据\n    one.onmessage = function (event) {\n      console.log(\"recv from one: \", event.data);\n\n      //结束一个线程\n      one.terminate();\n      two.terminate();\n      three.terminate();\n    }\n\n    two.onmessage = function (event) {\n      console.log(\"recv from two: \", event.data);\n    }\n\n\n    </script>\n\n/*\n one.js 文件\n*/\n/*\n接收主线程的指令，开始干活\nthis是该线程本身，不是window!!!!\n*/\n\nvar start,timer ;\n\n\nthis.onmessage = function (event) {\n  console.log(\"子线程 recve: \", event.data );\n  start = event.data;\n\n  timer = setInterval(function() {\n    start++;\n    console.log(start);\n    if (start === 120){\n      clearInterval(timer);\n\n      //给主线程发消息\n      postMessage(\"ok\");\n      return;\n    }\n  }, 1000);\n}\n\n\n/*\n  for.js文件\n*/\n//引入外部脚本\nimportScripts(\"./sum.js\");\nconsole.log(sum(10,20));\n\nconsole.log(location);\nconsole.log(navigator);\n\nsetInterval(function() {\n  console.log(\"----------------\");\n}, 1);\n\n/*\n sum.js文件\n*/\n\nfunction sum(arg1,arg2){\n  return arg1 + arg2;\n}\n\n","id":36,"date":1531559995120},{"editContent":"/*\n  这里就理解到了js 如何执行，和硬件内存相关活动。\n  调用函数前，“前一个”上下文环境会里面会被赋值，被压在下面，调用函数，进入新函数时，创建上下文环境，全局环境时做几方面：\n   变量或者表达式声明undefined； this赋值， 函数赋值;  如果是函数体，做几方面:  \n 变量或者表达式声明undefined,  自由变量确定作用域，参数赋值，伪数组arguments赋值；\n随之“压栈”。\n执行完了， 这个上下文就\"出栈\"， 销毁释放内存.\n*/\n\n行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境。当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境。处于活动状态的执行上下文环境只有一个。\n\n其实这是一个压栈出栈的过程——执行上下文栈。如下图：\n\n可根据以下代码来详细介绍上下文栈的压栈、出栈过程。\n\n如上代码。\n\n在执行代码之前，首先将创建全局上下文环境。\n\n然后是代码执行。代码执行到第12行之前，上下文环境中的变量都在执行过程中被赋值。\n\n执行到第13行，调用bar函数。\n\n跳转到bar函数内部，执行函数体语句之前，会创建一个新的执行上下文环境。\n\n并将这个执行上下文环境压栈，设置为活动状态。\n\n执行到第5行，又调用了fn函数。进入fn函数，在执行函数体语句之前，会创建fn函数的执行上下文环境，并压栈，设置为活动状态。\n\n待第5行执行完毕，即fn函数执行完毕后，此次调用fn所生成的上下文环境出栈，并且被销毁（已经用完了，就要及时销毁，释放内存）。\n\n同理，待第13行执行完毕，即bar函数执行完毕后，调用bar函数所生成的上下文环境出栈，并且被销毁（已经用完了，就要及时销毁，释放内存）。\n\n好了，我很耐心的给大家介绍了一段简短代码的执行上下文环境的变化过程，一个完整的闭环。其中上下文环境的变量赋值过程我省略了许多，因为那些并不难，一看就知道。","id":37,"date":1531566628503},{"editContent":"全局作用域， 函数作用域。\n限制变量。确定函数在哪个作用域定义.\n","id":38,"date":1531566813431},{"editContent":"全局作用域， 函数作用域。\n限制变量。确定函数在哪个作用域定义.\n\n作用域在函数定义时就已经确定了。而不是在函数调用时确定。\n\n作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了。\n\n如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值。\n要到创建这个函数的那个作用域中取值——是“创建”，而不是“调用”，切记切记——其实这就是所谓的“静态作用域”。\n\n\n作用域链：\n找变量，先到上下文环境找即所在函数作用域上下文，找不到就到定义该函数的上下文找，一直到全局作用域为止。这条路线就是“ 作用域链”\n\n闭包：\n特点：\n1.创建一个函数并且返回创建的函数，创建的函数引用了该作用域的变量\n2. 在创建的函数作用域内引用的变量是属于自由变量，在本函数执行完后不能销毁，否则在创建的函数执行是自由变量找不到赋值。（变量在使用的时候确定， 在使用的上下文环境找，找不到再到定义该函数的作用域的上下文找）).\n3.  增加了内存消耗","id":39,"date":1531574430981},{"editContent":"  function fun(a,b,c) {\n   \n       console.log(arguments.length); //结果是0\n       console.log(fun.length);//结果是3\n    }\nfun()\n\n","id":40,"date":1531578497095},{"editContent":"<script>\nfunction Person (name,age) {\n     this.name=name;\n     this.age=age;\n     this.sayHello = function () {\n       console.log(\"我是person\");\n     }\n   }\n   Person.prototype.sayHello = function () {\n     console.log(\"say hello ....\");\n   }\n   var person = new Person (\"lisi\",12);\n   console.log(\"person:\",person);\n   person.sayHello();\n   console.log(person.sayHello);\n   console.log(\"------------------\");\n\n   function Student (name,age,score ) {\n     this.name=name;\n     this.age= age;\n     this.score=score;\n   }\n   Student.prototype.a = 'hello';\n\n   Student.prototype = new Person();\nconsole.log(Student.prototype)  //这里会覆盖Student.prototype.a 变没了\n\n</script>","id":41,"date":1531579420547},{"editContent":"h5,标签潜入data-属性：\n需求：\n1.  可以存储一些简单数据。\n2.  可以用js动态获得，可以很方便组成对象。还可以css设置样式.\n\n<body>\n   <div data-a=\"hao\" , data-b =\"shengyin\", data-c =\"3\" class=\"data\" \n   data-abc-def=\"value\"></div>\n</body>\n<script>\n   var  dt = document.getElementsByClassName('data')[0]\n    var ds =  dt.dataset\n    var obj = {a: ds.a, b: ds.b,c:ds.c  }\n</script>","id":42,"date":1531583078854},{"editContent":"iframe嵌套页面，跨域\n父页面可以操作本页面iframe里面的标签对象，如css设置获取对象文本。但在真的页面是没有改变的。\n如window.name，window.names等父子之间可以传递数据， 但父页面改变不了真实页面的window属性值。","id":43,"date":1531620664846},{"editContent":"iframe嵌套页面，跨域\n父页面可以操作本页面iframe里面的标签对象，如css设置获取对象文本。但在真的页面是没有改变的。\n如window.name，window.names等父子之间可以传递数据， 但父页面改变不了真实页面的window属性值。","id":44,"date":1531620673297},{"editContent":"//NaN\n    console.log(typeof NaN);//number\n    console.log(10 * \"hello\"); //NaN\n\n    console.log(isNaN(\"hello\"));//true\n    console.log(isNaN(\"10\"));//false  隐式转换","id":45,"date":1531622109691},{"editContent":"1. ajax?\n  是一种向服务端发送异步请求，实现页面局部更新的web开发技术。\n\n2. ajax优缺点？\n优点：\n<1>.无刷新更新数据。\nAJAX最大优点就是能在不刷新整个页面的前提下与服务器通信维护数据。这使得Web应用程序更为迅捷地响应用户交互，并避免了在网络上发送那些没有改变的信息，减少用户等待时间，带来非常好的用户体验。\n<2>.异步与服务器通信。\nAJAX使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。优化了Browser和Server之间的沟通，减少不必要的数据传输、时间及降低网络上数据流量。\n<3>.前端和后端负载平衡。\nAJAX的原则是“按需取数据”，可以最大程度的减少冗余请求和响应对服务器造成的负担，提升站点性能。\n<4>.基于标准被广泛支持。\nAJAX基于标准化的并被广泛支持的技术，不需要下载浏览器插件或者小程序，但需要客户允许JavaScript在浏览器上执行。随着Ajax的成熟，一些简化Ajax使用方法的程序库也相继问世。同样，也出现了另一种辅助程序设计的技术，为那些不支持JavaScript的用户提供替代功能。\n\n缺点：\n1. AJAX干掉了Back和History功能，没有历史记录\n2. 增加了客户端的复杂度","id":46,"date":1531624136700},{"editContent":"console.log(Number(\"Hello world!\")); //NaN\n    console.log(Number(\"\")); //0\n    console.log(Number(\"0012345\")); //12345\n    console.log(Number(false)); //0\n    console.log(Number(true)); //1\n    console.log(Number(null)); //0\n    console.log(Number(undefined)); //NaN\n    console.log(\"---------------------------\");","id":47,"date":1531626081708},{"editContent":"for (var i = 0; i < 10; i++) {\n\n      if ((i % 2) === 1){\n        //立刻结束本次循环，开始下一次循环\n        //continue之后的代码不在运行，直接从下一次开始\n        continue;\n      }\n\n      console.log('i = ', i);\n    }\n\n\nfor (var i = 0; i < 5; i++) {\n\n      //break 默认跳出当前循环，不会影响外层循环\n      for (var j = 0; j < 5; j++) {\n        if (j === 2) {\n          break;\n        }\n        console.log(\"j = \", j);\n      }\n      console.log(\"i = \", i);\n    }\n\n\n break_point: for (var i = 0; i < 5; i++) {\n      for (var j = 0; j < 5; j++) {\n        if (j === 2) {\n          //break 跳出任意层循环\n          break break_point;\n        }\n        console.log(\"j = \", j);\n      }\n      console.log(\"i = \", i);\n    }\n","id":48,"date":1531626222570},{"editContent":" <script type=\"text/javascript\">\n\n\n    function fun(){\n      console.log(\"I am fun ...\");\n    }\n\n    var fun ;\n    console.log(fun);\n\n    /*\n    变量没有赋值： 变量在最顶部\n    变量赋值： 函数在最顶部，意思是取变量\n    */\n\n    </script>","id":49,"date":1531628237707},{"editContent":" <script type=\"text/javascript\">\n\n  \n    //逻辑与, 符号 &&\n    /*\n    javascript中的 && 得到的不一定是bool，而是最后的有效值\n\n    逻辑与运算的特点：短路特性, 从左向右依次运算，只要遇到一个可以转化为false的，那么该运算立刻结束，后边的操作不再运算\n    */\n\n    console.log(10 && 0);//0\n    console.log(10 && 20);//20\n    console.log(0 && 30);//0\n    console.log(false && 50);//false\n    console.log(50 && true);//true\n    console.log(true && 60);//60\n\n    var a = undefined;\n    console.log(10  && 0 &&  (a = 20));\n    console.log(\"a = \", a);\n\n\n    /*\n    逻辑或：||\n    ||  得到的不一定是bool，第一个有效值\n    特点： 短路特性，  短路特性, 从左向右依次运算，只要遇到一个可以转化为true的，那么该运算立刻结束，后边的操作不再运算\n    */\n\n    console.log(10 || 0);//10\n    console.log(0 || 20);\n\n    var b = undefined;\n    console.log(0 || 10 || (b = 20));//10\n    console.log(b);//undefined\n </script>","id":50,"date":1531628888990},{"editContent":" <script type=\"text/javascript\">\n\n  \n    //逻辑与, 符号 &&\n    /*\n    javascript中的 && 得到的不一定是bool，而是最后的有效值\n\n    逻辑与运算的特点：短路特性, 从左向右依次运算，只要遇到一个可以转化为false的，那么该运算立刻结束，后边的操作不再运算\n    */\n\n    console.log(10 && 0);//0\n    console.log(10 && 20);//20\n    console.log(0 && 30);//0\n    console.log(false && 50);//false\n    console.log(50 && true);//true\n    console.log(true && 60);//60\n\n    var a = undefined;\n    console.log(10  && 0 &&  (a = 20));\n    console.log(\"a = \", a);\n\n\n    /*\n    逻辑或：||\n    ||  得到的不一定是bool，第一个有效值\n    特点： 短路特性，  短路特性, 从左向右依次运算，只要遇到一个可以转化为true的，那么该运算立刻结束，后边的操作不再运算\n    */\n\n    console.log(10 || 0);//10\n    console.log(0 || 20);\n\n    var b = undefined;\n    console.log(0 || 10 || (b = 20));//10\n    console.log(b);//undefined\n </script>","id":51,"date":1531629311399},{"editContent":" <script type=\"text/javascript\">\n\n  //逗号，最后一个表达式的值为整个逗号运算的值\n    var result = (num1++, num2++, num3++);\n    console.log(\"result = \", result); //4\n    console.log(\"num1 = \", num1); //2\n    console.log(\"num2 = \", num2); //3\n    console.log(\"num3 = \", num3); //5\n\n\n\n    var num4 = 5 ;\n    result = (num4++, num4++, num4++);\n    console.log(\"result = \", result); //7\n    console.log(\"num4 = \", num4); //8\n </script>","id":52,"date":1531629338185},{"editContent":"// console.log($.fn.jquery);//输出版本号\n\n    //当前的juqery版本放弃使用$符号,但是并没有放弃jQuery\n    //返回值是新的符号\n    /*\n    var $$ = $.noConflict();\n    console.log($.fn.jquery);//3.0.0\n    //$$ === jQuery仍然是1.12.4版本\n    console.log($$.fn.jquery);//1.12.4\n    console.log(jQuery.fn.jquery);//1.12.4\n    */\n\n    /*\n    $.noConflict();\n    console.log($.fn.jquery);//3.0.0\n    console.log(jQuery.fn.jquery);//1.12.4\n    */\n\n    var $$ = $.noConflict(true);  //true表示jQuery都不要了\n    console.log($$.fn.jquery);//1.12.4\n    console.log($.fn.jquery);//3.0.0\n    console.log(jQuery.fn.jquery);//3.0.0","id":53,"date":1531630800474},{"editContent":"## link的作用\n*  引入样式表(浏览器是单独加载样式表)\n*  开启dns预解析\n*  引入tab的icon\n\n## @import\n* @import 引入样式表只能在样式中填写\n* @import 引入样式表是阻塞加载的（如果该样式表加载不完，那么后续的其他内容都不能解析","id":54,"date":1531631066905},{"editContent":"<style>\n    <!--[if lt ie 9]>\n    <style>\n    .s {\n    color: red;\n  }\n</style>\n<![endif]-->\n</style>\n\n<body>  \n<!--[if lt ie 9]>\n     <p>我是ie9以下的浏览器</p>\n    <![endif]-->\n</body>","id":55,"date":1531631344285},{"editContent":"默认最小高度问题。\n低版本的ie会有不支持 min-height属性\n/*图片默认有横向间隙，使用float解决*/\n  /*ie8以下的透明度问题*/ 解决 filter:   alpha(opacity=50);\n\n使用hackcss样式，或者条件注释","id":56,"date":1531642790867},{"editContent":"    //DOM0的事件添加方式！！！！！！\n    //DOM0 无法指定多个处理函数\n    btn1.onclick = function () {\n      console.log(\"btn1...\");\n    };\n\n    btn2.ondblclick = function () {\n      console.log(\"btn2.. 1...\");\n    };\n\n    //移除处理函数\n    btn2.ondblclick = null;\n","id":57,"date":1531645039614},{"editContent":"解决需求：父节点和子节点发生事件的先后顺序问题\n\n事件冒泡：  从最里面的节点开始向外传递。\n事件捕获：  从最外面的节点开始向内传递。\n\nDOM2 事件冒泡false，事件由内向外；　事件捕获true，事件由外向内","id":58,"date":1531645434098},{"editContent":"/*\n 添加事件\n*/\n\nfunction addEvent(obj, eventName, handler ) {\n  if(obj.addEventListener) {\n   obj.addEventListener(eventName,  handler, false)\n} else if(obj.attachEvent) {\n   obj.attachEvent('on'+eventName, handler, false)\n}else {\nobj['on'+eventName] = handler\n}","id":59,"date":1531646094045},{"editContent":"<body>\n\n  <div id=\"f\">\n    <button id=\"btn\">按钮</button>\n  </div>\n  <a href=\"https://www.baidu.com\" id=\"link\">超链接</a>\n\n  <div id=\"box\"></div>\n\n\n\n  <script type=\"text/javascript\">\n    var btn = document.getElementById(\"btn\");\n    var f = document.getElementById(\"f\");\n    var link = document.getElementById(\"link\");\n    var box = document.getElementById(\"box\");\n\n\n    btn.onclick = function(e) {\n      // console.log(event);\n      console.log(\"btn............\");\n      console.log(this); //this是注册该事件处理函数的元素\n      console.log(e.currentTarget); //等价于this\n      console.log(e.target); //表示触发事件的源头元素\n\n\n      //停止事件传播， 父元素不能触发了.\n      // e.stopPropagation();\n    };\n\n\n    f.onclick = function(e) {\n      console.log(\"f............\");\n      console.log(this); //this是注册该事件处理函数的元素\n      console.log(e.currentTarget); //等价于this\n      console.log(e.target); //表示触发事件的源头元素\n    };\n\n\n    link.onclick = function(e) {\n      console.log(\"我被取消了。。。。\");\n\n      //阻止默认行为\n      e.preventDefault();\n    };\n\n    document.onclick = function (e) {\n      //page是整个页面\n      console.log(\"pageX  = \", e.pageX);\n      console.log(\"pageY  = \", e.pageY);\n\n      //screen整个屏幕\n      console.log(\"screenX= \", e.screenX);\n      console.log(\"screenY= \", e.screenY);\n\n      //client浏览器可视窗口\n      console.log(\"clientX= \", e.clientX);\n      console.log(\"clientY  = \", e.clientY);\n    }\n\n\n  </script>\n\n</body>","id":60,"date":1531647524381},{"editContent":"<body>\n\n    <div id=\"box\"></div>\n    <textarea id=\"text\" rows=\"8\" cols=\"80\"></textarea>\n\n    <script>\n      var box = document.getElementById(\"box\");\n      var text = document.getElementById(\"text\");\n\n      //e.button可以知道那个键被按下\n      box.onclick = function (e) {\n        console.log(\"click\",e.button);\n      };\n\n      box.oncontextmenu = function (e) {\n        console.log(\"contextmenu\",e.button);\n      };\n\n      box.onmouseup = function (e) {\n        console.log(\"mouseup: \", e.button);\n      }\n\n      text.onkeyup = function (e) {\n        console.log('输入为： ', e.key);\n      }\n\n\n      var start = 0, end = 0;\n\n      document.addEventListener('touchstart', function(e){\n        start = e.targetTouches[0].clientX;\n        console.log(start);\n      },false);\n\n\n      document.addEventListener('touchend', function(e){\n        end = e.changedTouches[0].clientX;\n        console.log(end);\n\n        if (end >= start){\n          console.log(\"right\");\n        } else if (end < start) {\n          console.log(\"left\");\n        }\n      },false);\n\n\n\n\n\n\n    </script>\n\n  </body>","id":61,"date":1531647763817},{"editContent":"Dom0, Dom2 :\n**.onclick =   function (e) {\n    /*\n    e表示注册该函数的事件的对象, === this\n    e.currentTarget  ===this.\n    e.target   触发事件的源头\n    e.stopPropagation() 阻止事件传播\n    e.preventDafult()  阻止默认事件 \n*/\n  \n}\n在ie事件中,  没有用到e 了， this == window.event,  window.srcElement 等价于之前e.target ,  阻止传播事件 window.event.cancelBubble = true;  阻止默认行为window.event.returnValue = false;\n","id":62,"date":1531648746813},{"editContent":"<body>\n\n    <button id=\"btn\">按钮</button>\n\n    <ul class=\"list\">\n      <li>0</li>\n      <li>1</li>\n      <li>2</li>\n    </ul>\n\n    <script src=\"./jquery-3.0.0.min.js\" charset=\"utf-8\"></script>\n    <script type=\"text/javascript\">\n\n    $(\"#btn\").click([1,2,3], function(event){\n      console.log(event.data);\n    });\n\n    var lists = $(\".list li\");\n    console.log(lists);\n\n    //使用原生方法给3* li添加单击事件\n    for (var i = 0; i < lists.length; i++) {\n\n      /*\n      //闭包，导致的副作用，最后的i都一样\n      lists[i].onclick = function(){\n        console.log(i);//3\n      }\n      */\n\n      //第一种解决方法\n      // lists.eq(i).click(i,function(event){\n      //   console.log(event.data);\n      // });\n\n\n      //第二种解决方法，立即函数，只执行一次，形成一个独立的作用域，所以i传进去，每个li注册的事件都有独立的作用域，i在上下文环境中\n      // (function(i){\n      //   lists[i].onclick = function(){\n      //     console.log(i);\n      //   }\n      // })(i);\n\n      //第三种解决方法，把i存储到对象的属性\n      // lists[i].index = i;\n      // lists[i].onclick = function(){\n      //   console.log(this.index);\n      // }\n\n    }\n\n\n\n\n\n    </script>\n\n  </body>","id":63,"date":1531650123645},{"editContent":"学习节点这一关， 学习属性和方法涉及要几个方面， 一是自身属性， 二是子元素，三是父元素， 四是同胞元素。\n\n自身， 如nodeType, nodeName, setAttribute()\n子元素:  查找， getElementById() ..., .nextSibling//包含了文本;\n    //获得下一个节点，只包含元素，文本不算.nextElementSibling;\n //查找子节点.firstChild; \n  .lastChild;  .firstElementChild;  .lastElementChild;\n\n    //获得所有的子节点\n    .childNodes包括了文本;   .children[3]只有元素; \n父元素:  .parentNode\n\n //创建一个新节点\n    var node1 = document.createElement(\"div\");\n    //给节点添加内容\n    node1.innerHTML = \"<p>我是div</p>\";\n\n    //添加节点\n    //xxx.appendChild()\n    box1.appendChild(node1);\n\n\n\n    var  node2 = document.createElement(\"h1\");\n    node2.innerHTML = \"大标题\";\n    // box1.insertBefore(node2,null);//第二个参数为null，等价于appendChild\n    box1.insertBefore(node2,son);\n\n   //删除节点 xxx.removeChild\n   var oldChild = box1.removeChild(box1.lastElementChild);\n   console.log(oldChild);\n\n   //替换，replace\n   box1.replaceChild(oldChild, box1.firstElementChild);","id":64,"date":1531651744283},{"editContent":" var jq = $(\"button\")\nvar dom= document.getElementById('btn')\n\njquery  ===>  dom\n$(dom)\n\ndom ===> jquery\njq[0] 或者jq.get(0)","id":65,"date":1531652844852},{"editContent":"间隔定时器：  setInterval,  每隔一定时间就把回调函数放到事件队列中。\n超时定时器：  setTimeout  只执行一次，到了时间就把回调函数放到事件队列。","id":66,"date":1531658420298},{"editContent":"<script type=\"text/javascript\">\n\n    console.time(\"start\");\n    for (var i = 0; i < 10000; i++) {\n      console.log(i);\n    }\n    console.timeEnd(\"start\");\n\n  </script>","id":67,"date":1531658441348},{"editContent":"<script type=\"text/javascript\">\n\n    console.time(\"start\");\n    for (var i = 0; i < 10000; i++) {\n      console.log(i);\n    }\n    console.timeEnd(\"start\");\n\n  </script>","id":68,"date":1531658489256},{"editContent":" <script type=\"text/javascript\">\n\n  /*\n  一道经典闭包题目？？？？？？\n  */\n    function fun(n, o) {\n      console.log(o)\n      return {\n        fun: function(m) {\n          return fun(m, n);\n        }\n      };\n    }\n\n    //a: undefined,0,0,0\n    var a = fun(0);//先上下文环境，fun赋值， a,b 为undefined, 到这行，调用fun函数，跳到fun函数，上下文准备， 压栈，这里最后执行完得到一个对象{ fun: function}, 因为 对象里面引用了自由变量n，所以大fun栈被保留，上下文保留 n == 0\n    a.fun(1); //先在全局上下文找到a，这里最后也是返回了一个对象{fun： function}\n    a.fun(2); //先在全局上下文找到a，这里最后也是返回了一个对象{fun： function}\n    a.fun(3);\n\n    //b: undefined,0,1,2\n    var b = fun(0).fun(1).fun(2).fun(3);//先在全局上下文找到a，返回对象在运算又返回对象又运算又返回对象，fun上下文m, n不停的变\n\n    //c: undefined,0,1,1\n    var c = fun(0).fun(1);\n    c.fun(2);\n    c.fun(3);\n  </script>","id":69,"date":1531661373036},{"editContent":"闭包定义：   /*\n      创建闭包：在一个函数A中，返回一个函数，并且返回这个函数中引用到了A函数中的变量。 那么返回的这个函数就是闭包。\n\n/*\n            全局变量容易被修改，没有办法保护。\n            而且全局资源有限，需要尽可能的减少全局变量的定义。\n            */\n    // var count = 0;\n\n    /*\n     闭包的优点：\n     1. 减少全局变量的定义，实现变量的私有化\n     2. 可以根据不同参数，动态生成一些值。\n\n     缺点：\n     1. 私有变量会常驻内存，直到该变量使用完毕，会增加内存消耗\n    */\n","id":70,"date":1531662304799},{"editContent":"<!--\n    面向对象：所有的操作都是以对象为中心，围绕对象展开，对象拥有属性和方法，属性和方法都是对象的附属。\n    特点：封装 继承 多态\n    -->","id":71,"date":1531663406002},{"editContent":"\n    <script type=\"text/javascript\">\n\n    function Person(name,age){\n      this.name = name;\n      this.age = age;\n    }\n\n    Person.prototype.sayHello = function () {\n      console.log(\"hello...\");\n    };\n\n    Person.prototype.hobby = [1,2,3,4];\n\n\n    var one = new Person('lisi', 22);\n\n    // one.hobby = [10,2,3,4];//直接赋值，那么就是添加自己属性\n    one.hobby.push(20);//直接在已有的基础上修改，当然修改的就是原型了\n\n    var two = new Person('zhangsan', 20);\n\n    console.log(\"one = \", one);\n    console.log(\"two = \", two);//two的two.hobby也变了，对象也可以改构造函数的原型\n\n    </script>","id":72,"date":1531663477850},{"editContent":"\n    <script type=\"text/javascript\">\n\n    function Person(name,age){\n      this.name = name;\n      this.age = age;\n    }\n\n    Person.prototype.sayHello = function () {\n      console.log(\"hello...\");\n    };\n\n    Person.prototype.hobby = [1,2,3,4];\n\n\n    var one = new Person('lisi', 22);\n\n    // one.hobby = [10,2,3,4];//直接赋值，那么就是添加自己属性\n    one.hobby.push(20);//直接在已有的基础上修改，当然修改的就是原型了\n\n    var two = new Person('zhangsan', 20);\n\n    console.log(\"one = \", one);\n    console.log(\"two = \", two);//two的two.hobby也变了，对象直接赋值就是添加基础属性，但如果在已有基础上修改可以改构造函数的原型\n\n    </script>","id":73,"date":1531664052594},{"editContent":"第一种原型链继承：\n\n   function Person(name,age){\n     this.name = name;\n     this.age = age;\n   }\n\n   Person.prototype.sayHello = function () {\n     console.log(\"say hello ...\");\n   };\n\n\n   function Student(name,age,score){\n     this.name = name;\n     this.age = age;\n     this.score = score;\n   }\n\n   //仍然继承了重复的name,age,而且将来Studen又会覆盖掉name,age吧\n   Student.prototype = new Person();//name,age,sayHello\n\n   //指定自己的constructor,因为上一步被覆盖了\n   Student.prototype.constructor = Student;\n\n\n  var one = new Student(\"zhansan\", 22,88);\n  console.log(one);\n  // one.sayHello();\n  // console.log(one.constructor);//Student\n  //student可能继承了Person一些无用属性，因为student有些属性也有.  重点是继承了Person原型里面方法. student.__proto__ 引用了Person的原型.\n\n\n\n借用构造函数实现继承:\n function Person(name, age) {\n      this.name = name;\n      this.age = age;\n    }\n\n    Person.prototype.sayHello = function() {\n      console.log(\"say hello ...\");\n    };\n\n\n    function Student(name,age,score){\n\n      //借用Person构造函数\n      //只能继承构造函数内部的属性，但是原型的属性和方法无法实现继承！！！！\n      Person.call(this,name,age);\n      this.score = score;\n    }\n\n\n    var one = new Student('lisi', 22, 59);\n    console.log(one);\n\n\n\n\n/*\n    组合继承 = 原型链继承 + 借用构造函数继承\n*/\n function Person(name, age) {\n      this.name = name;\n      this.age = age;\n    }\n\n    Person.prototype.sayHello = function() {\n      console.log(\"say hello ...\");\n    };\n\n\n    \n    function inherit(sup, sub){\n      function Fun(){}; //为了在原型链继承的时候去掉无用属性\n      Fun.prototype = sup.prototype; //生成对象通过__proto__引用了生成改对象的函数的原型。\n      sub.prototype = new Fun();\n      sub.prototype.constructor = sub ;\n    }\n\n\n    function Student(name,age,score) {\n      Person.call(this,name,age);\n      this.score = score;\n    }\n\n    // Student.prototype = new Person();\n    // Student.prototype.constructor = Student;\n\n    inherit(Person,Student);\n\n    Student.prototype.exam = function () {\n      console.log(\"exam ...\");\n    };\n\n\n    var one = new Student('lisi', 22, 60);\n    var two = new Student('zhangsan', 20, 68);\n    console.log(one,two);\n","id":74,"date":1531666709898},{"editContent":"两者都是为函数制定this,  即this为传入的对象.\ncall方法的参数为单个参数， 参数可以为任何类型\napply方法只能为数组","id":75,"date":1531705452050},{"editContent":"xml  类似html标签形式， 数据操作变成Dom操作。\n<script type=\"text/javascript\">\n    //xml的解析！！！！\n\n    var xmlStr =\n      `\n    <rss version='2.0'>\n     <stu>\n       <name id='name'>lisi</name>\n       <age>10</age>\n       <gender>male</gender>\n       <hobby>\n         <one>read</one>\n         <one>sport</one>\n         <one>code</one>\n       </hobby>\n     </stu>\n     </rss>\n     `;\n    console.log(xmlStr);\n\n    //使用jQuery.parseXML();\n    var ret = $.parseXML(xmlStr);\n    console.log(ret);//DOM对象\n\n    //获取其中的值\n    console.log($(ret).find(\"#name\").html());\n    console.log($(ret).find(\"hobby one\").eq(0).html());//eq(x)得到的是jQuery对象\n    console.log($(ret).find(\"hobby one\")[0].innerHTML);//[x]得到是DOM对象！！！！！！\n\n\n\n\n    //原生方法解析XML\n    var str = `\n    <stu>\n      <name>lisi</name>\n      <age>10</age>\n      <gender>male</gender>\n      <hobby>\n        <one>read</one>\n        <one>sport</one>\n        <one>code</one>\n      </hobby>\n    </stu>\n    `;\n\n    var parser = new DOMParser();//实验中的功能\n    var ret = parser.parseFromString(str,\"application/xml\");\n    //原生方法解析!!!!!\n    console.log(ret.getElementsByTagName(\"name\")[0].innerHTML);\n\n\n\n\n\n   /*\n   json VS xml???\n   */\n\n\n\n  </script>","id":76,"date":1531706126136},{"editContent":"var ret =  字符串.match(//)\nret为数组， 数组[0]为匹配到的，  如果有捕获就是从数组[1]开始，  index为匹配到在字符串的位置\n\n //String.prototype.match()方法\n\n\n      // * 默认是贪婪匹配？？？\n      /*\n      *， + 后边携带 ？用于最短匹配\n      取消贪婪匹配，进行最短匹配！！！！！！\n      */\n      var ret = \"worldhelloooooooo\".match(/hello*?/);\n      console.log(ret);\n      /*\n      ret[0]是匹配的字符串\n      index\t匹配到的字符位的开始位置\n      input\t原始字符串\n      */\n\n\n      //正则表达式中用 ( )包裹的部分就是捕获\n      //match方法中，从数组[1]开始的都是捕获\n      var ret = \"kkworldhelloooooooo\".match(/world(hello+?)/);\n      console.log(ret);\n\n\n  .match(//)  匹配多个就会返回数组\n  .exec(//)  放在while有匹配就循环遍历","id":77,"date":1531711105274},{"editContent":"var st = [\"习近平\"，\"周永康\"]\nst = st.join('|')\nreg = new RegExp(st, g)\n\n var ret =    *******.replace(reg, function(match) {\n  return '<mark>' + match + '</match>'\n})","id":78,"date":1531711850677},{"editContent":"/*\n  返回一个指定了this的新函数， this不会变了\n*/\n\n\n var value = 0;\n      var btn = document.getElementById(\"btn\");\n      btn.value = 100;\n\n      function fun(arg1,arg2){\n        console.log(this.value);\n        console.log(arguments);\n      }\n\n      // fun(1,2);\n      var obj = {\n        value: 10\n      };\n\n      /*\n      返回一个指定了this值的新函数，newFun\n      不管将来在什么环境中调用，this都不会变化了\n      */\n      var newFun = fun.bind(obj,1,2,3,4,5,6);\n      newFun(10,20);//最终的参数是所有参数的组合！！！！\n\n\n\n      /*\n      根据自己的需求，可以多次bind\n      */\n      var newFun1 = fun.bind(btn,1,2,3);\n      var newFun2 = fun.bind(btn,1,2,3);\n\n      console.log(newFun1 === newFun2);//false\n      btn.addEventListener('click', newFun1, false);","id":79,"date":1531712907681},{"editContent":"/*\n  返回一个指定了this的新函数， this不会变了\n*/\n\n\n var value = 0;\n      var btn = document.getElementById(\"btn\");\n      btn.value = 100;\n\n      function fun(arg1,arg2){\n        console.log(this.value);\n        console.log(arguments);\n      }\n\n      // fun(1,2);\n      var obj = {\n        value: 10\n      };\n\n      /*\n      返回一个指定了this值的新函数，newFun\n      不管将来在什么环境中调用，this都不会变化了\n      */\n      var newFun = fun.bind(obj,1,2,3,4,5,6);\n      newFun(10,20);//最终的参数是所有参数的组合！！！！\n\n\n\n      /*\n      根据自己的需求，可以多次bind\n      */\n      var newFun1 = fun.bind(btn,1,2,3);\n      var newFun2 = fun.bind(btn,1,2,3);\n\n      console.log(newFun1 === newFun2);//false\n      btn.addEventListener('click', newFun1, false);","id":80,"date":1531713573249},{"editContent":"dom对象s\n\ns.offsetTop  s.ffsetLeft  只读\ns.style.left  设置\n\n$(s).offset() 读 $(s).offset({top:  ***, left: ***}) 设置","id":81,"date":1531714687493},{"editContent":"window.open(\"http://www.w3school.com.cn\")\n","id":82,"date":1531716646961},{"editContent":"首先使用iframe嵌套页面.  实现父页面和嵌套页面hash都变化. \n\n父页面: \n1. 得到嵌套页面iframe对象， 得到连接属性src ,\n同时可以得到嵌套页面的window对象 iframe.contentWindow,进行设置  iframe.contentWindow.document.getElementById(**).style.color = 'red'\n\n2. 父页面使用定时器，为嵌套页面添加hash,  形式大概是 \niframe.contentWindow.location.href =   iframe.src + ‘#’+ data数据；  父页面监听hash变化, window.onhashchange事件, 相关hash属性， window.location.hash,  \n\n3 嵌套页面监听自身hash变化， window.onhashchange改变事件, 相关父页面属性，  window.parent.location.href  ,  利用  window.parent.location.href + ‘#’+ data数据改变父页面的hash\n\n /*\n  window.onhashchange, window.location.href, window.location.hash\n*/\n","id":83,"date":1531724765663},{"editContent":"利用script标签发出get请求. 通过src携带函数名如 callback = \"函数名\"， 后台接收到相应请求，得到并返回该字段 req.query.callback +‘（’ + data数据+ ')'  \n\n ","id":84,"date":1531726623303},{"editContent":"\n    try {\n      //把可能出现错误的代码填写在try中，但是有些错误是无法处理必须报错的，将来出现错误之后，可以继续运行，而不会崩溃！！！！\n      //一旦在某处抛出了错误，那么try中的其他代码将不再执行\n      // console.log(a);\n\n      console.log(10/0);//Infinity\n      console.log(2*Number.MAX_VAlUE);//NaN\n\n\n      // /* 自定义错误，并且手动抛出错误！！！！*/\n      var err = new Error(\"自定义错误\", \"05.try.html\", \"18\");\n      throw err;//抛出错误\n\n\n\n    } catch(e){\n\n      //instanceof 用于测试对象是否属于某个构造函数!!!!\n      if (e instanceof ReferenceError){\n        console.log(\"引用错误\");\n      } else if (e instanceof Error){\n        console.log(\"Error....\");\n      }\n\n\n\n      //用于捕获出现的错误，参数就是错误对象\n      console.log(\"捕获错误\",e);\n    } finally{\n\n      //无论是否有错误，那么finally都会执行\n      console.log(\"in finally .....\");\n    }\n\n\n    console.log(\"success........\");\n\n\n    /*\n    嵌套try可以，如果没有catch，那么错误会向外传递，直到遇到一个catch为止！！！！！！\n    */","id":85,"date":1531727538254},{"editContent":"1.   利用window.open打开一个新窗口携带window.name , iframe嵌套页面\n2.    利用hash携带数据,  iframe嵌套页面。使用到window.onhashchange事件，  window.location.hash,  window.location.href\n3  利用新h5API， window.postMessage, 大概是window.open打开新窗口， window.poseMessage(数据)，  onmessage监听\n4.  jsonp， 利用script发出get请求， 携带函数名.\n5 . 后台设置允许跨域. ","id":86,"date":1531727894559},{"editContent":"dfafaf","id":87,"date":1531807722473},{"editContent":"","id":88,"date":1531807936695},{"editContent":"fafa","id":89,"date":1531807977529},{"editContent":"hhh","id":90,"date":1531808048727},{"editContent":"jsjsjs","id":91,"date":1531808843085},{"editContent":"dfaf","id":92,"date":1531808929076},{"editContent":"开会啦","id":93,"date":1531809433902},{"editContent":"hafjalfj","id":94,"date":1531809493028},{"editContent":"css","id":95,"date":1531809699290},{"editContent":"输入url发生了什么？\n1. 进行DNS域名解析，找到对应的主机ip\n2. 在浏览器和主机之间，建立网络连接\n3. 浏览器给主机发送http请求\n4. 服务器接收请求，并根据请求查找相关资源，并返回给浏览器结果\n5. 浏览器接收服务器的响应，根据响应内容进行渲染，将网页显示在浏览器中","id":96,"date":1531812856891},{"editContent":"输入url发生了什么？\n1. 进行DNS域名解析，找到对应的主机ip\n2. 在浏览器和主机之间，建立网络连接\n3. 浏览器给主机发送http请求\n4. 服务器接收请求，并根据请求查找相关资源，并返回给浏览器结果\n5. 浏览器接收服务器的响应，根据响应内容进行渲染，将网页显示在浏览器中","id":97,"date":1531812864978},{"editContent":"\n语义化：就是根据网页的内容和结构，选择对应的语义化标签。可以使页面在没有css的情况下\n仍然能做到结构清晰，组织有序，偏于搜索引擎优化，有利于其他设备进行解析。","id":98,"date":1531812893315},{"editContent":"<meta http-equiv=\"Cache-Control\" content=\"no-siteapp\" />","id":99,"date":1531813257646},{"editContent":"<meta http-equiv=\"Cache-Control\" content=\"no-transform\" />\n<meta http-equiv=\"Cache-Control\" content=\"no-siteapp\" />","id":100,"date":1531813430866},{"editContent":"this指向，  定义时所在的对象 ， 如在一个函数里面就是这个函数实例对象","id":101,"date":1531884390829},{"editContent":"\n如果把数据看成一个对象， 如果只有一个属性，属性下面同类数据就组成 [{},{},{}]，否则就要向下面这种:\n\nproductList : {\n\t\t\t\t\t\"pc\": {\n\t\t\t\t\t\t'title' : 'PC产品',\n\t\t\t\t\t\t'list': [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tname: '数据预测',\n\t\t\t\t\t\t\t\turl: 'http://www.baidu.com'\n\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tname: '流量分析',\n\t\t\t\t\t\t\t\turl: 'http://www.baidu.com',\n\t\t\t\t\t\t\t\thot: true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tname: '广告分布',\n\t\t\t\t\t\t\t\turl: 'http://www.baidu.com'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t],\n\t\t\t\t\t\thr: true\n\t\t\t\t\t},\n\t\t\t\t\t\"app\": {\n\t\t\t\t\t\ttitle: '手机应用类',\n\t\t\t\t\t\tlist: [ \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tname: '91助手',\n\t\t\t\t\t\t\t\turl: 'http://www.baidu.com'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: '91助手',\n\t\t\t\t\t\t\turl: 'http://www.baidu.com'\n\t\t\t\t\t\t},\n\t\t\t\t\t\t]\n\n\n\t\t\t\t\t}\n\t\t\t\t},","id":102,"date":1531907600583},{"editContent":"computed计算属性， 可以当作一个data来用，里面进行了逻辑运算再返回数据.\n\n/*\n  轮播图中向前向后箭头点击使用computed返回数据实现\n*/\n<div class=\"slide-pages\">\n\t<ul >\n\t   <li @click=\"goto(preventIndex)\">&lt;</li>\n\t   <li v-for=\"(list , index ) in slider\" @click=\"goto(index)\" >\n\t    <a :class=\"{on: index == nowIndex}\">{{index+1}}</a>\n\t  </li>\n\t <li @click=\"goto(nextIndex)\">&gt;</li>\n</ul>\n\n<script>\n   methods: {\n\t\t\tgoto(index) {\n\t\t\t\t\n\t\t\t\tthis.slideShow = false;\n\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tthis.slideShow = true;\n\t\t\t\t\tthis.nowIndex = index;\n\t\t\t\t\tthis.$emit(\"sliderChange\",this.nowIndex+1)\n\t\t\t\t},10)\n\t\t\t}\n},\ncomputed: {\n\t\t\tpreventIndex() {\n\t\t\t\tif(this.nowIndex ==0) {\n\t\t\t\t\treturn\tthis.slider.length-1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn this.nowIndex - 1;\n\t\t\t\t}\n\t\t\t},\n\t\t\tnextIndex() {\n\t\t\t\tif(this.nowIndex == this.slider.length-1){\n\t\t\t\t\treturn 0\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn this.nowIndex + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n</script>","id":103,"date":1531909636017},{"editContent":"hhh","id":104,"date":1531909715700},{"editContent":"/*\n   computed 计算属性当参数用。 几个li下a连接不同上面显示不同图片,  不能定义data（）里面数据，因为每次刷新都会回到默认值. 这里用了路由， 根据路由不同跳到不同头像\n*/\n<template>\n<div>\n\t\t\t\t<img :src=\"productImg\" alt=\"\">\n\t\t\t</div>\n\t\t\t<ul>\n\t\t\t\t<li v-for=\"(item,index) in list\" ><a :href=\"item.url\">{{item.name}}</a></li>\n\t\t\t</ul>\n\t\t</div>\n</template>\n\n<script>\ndata() {\n\t\t\treturn {\n\t\t\t\tnowIndex: 0,\n\t\t\t\tlist: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tname: '数据统计',\n\t\t\t\t\t\t\t\turl: 'analynic',\n\t\t\t\t\t\t\t\timg: require('../assets/images/earth.png')\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tname: '数据预测',\n\t\t\t\t\t\t\t\turl: 'traffic',\n\t\t\t\t\t\t\t\timg: require('../assets/images/car.png')\n\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tname: '流量分析',\n\t\t\t\t\t\t\t\turl: 'predict',\n\t\t\t\t\t\t\t\timg: require('../assets/images/horn.png'),\n\t\t\t\t\t\t\t\thot: true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t  name: '广告分布',\n\t\t\t\t\t\t\t\turl: 'adverti',\n\t\t\t\t\t\t\t\timg: require('../assets/images/car.png')\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t],\n\t\t\t\tproductIcon: {\n\t\t\t\t\t'/detail/analynic': require('../assets/images/earth.png'),\n\t\t\t\t\t'/detail/traffic': require('../assets/images/car.png'),\n\t\t\t\t\t'/detail/predict': require('../assets/images/horn.png'),\n\t\t\t\t\t'/detail/adverti': require('../assets/images/car.png'),\n\n\t\t\t\t}\n\t\t\t}\n\t\t},\n  computed: {\n\t\t\tproductImg() {\n\t\t\t\tconsole.log(this.$route.path)\n\t\t\t\treturn this.productIcon[this.$route.path]\n\t\t\t}\n\t\t}\n</script>","id":105,"date":1531911304815},{"editContent":"/*\n @这里3组按钮， 通过设定一个变量数组保存index, 每一次点击就就行判断， 数组没有就添加， 有了就删除。\n@ 判断完后，在把变量数组遍历， 新建立空数组[  ]拿到对应index数据。\n@拿到了身份证版的index，你想干嘛就干嘛\n*/\n<template>\n\t<div class=\"versions\">\n\t\t<button v-for=\"(item ,index) in versions\" type=\"\" :class=\"{green: checkActive(index) }\" @click=\"changeVersion(index)\">{{item.text}}</button>\n\t\t\n\t</div>\n</template>\n<script type=\"text/javascript\">\nimport _ from 'lodash'\n\t\n\texport default {\n\t\tprops: {\n\t\t\tversions: {\n\t\t\t\ttype: Array,\n\t\t\t\tdefault: [\n\t\t\t\t\t{\n\t\t\t\t\t\t'text': 'test',\n\t\t\t\t\t\t'value': 0\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t}\n\t\t},\n\t\tdata() {\n\t\t\treturn {\n\t\t\t\tactive: [0]\t\n\t\t\t}\n\t\t\t\n\t\t},\n\t\tmethods: {\n\t\t\tchangeVersion(index) {\n\t\t\t\tif(this.active.indexOf(index) == -1) {\n\t\t\t\t\tthis.active.push(index)\n\t\t\t\t}else {\n\t\t\t\t\tthis.active = _.remove(this.active,(idx) =>{\n\t\t\t\t\t\treturn idx != index\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\tlet ret = []\n\t\t\t\tthis.active.forEach((e,i) => {\n\t\t\t\t\tret.push(this.versions[e])\n\n\t\t\t\t})\n\t\t\t\t// console.log(ret)\n\t\t\t\tthis.$emit('onChange',ret)\n\n\t\t\t},\n\t\t\tcheckActive(index) {\n\t\t\t\treturn this.active.indexOf(index) !== -1\n\t\t\t}\n\t\t}\n\t}\n</script>","id":106,"date":1531918414271},{"editContent":"/*\n 用户管理+ 平台管理权限  实现\n*/\n\n1.出使时，页面发回含后权限的字段数组。sessionStorage保存\n2. 遍历权限字段数组，一个一个进行判断，DOm显示display\n3.  处理用户管理和管理员管理， 这里是普通权限后台发回一个字段对象competence.list[0].username == sessionStorage.login,  如是管理员权限发回所有字段对象\n4. 教学课件不用权限\n   if(data.username == sessionStorage.login) {\n\t\t\t\t\tvar dataQuanLi = JSON.parse(data.competence);\n\t\t\t\t\tdataQuanLi.forEach(function(e) {\n\t\t\t\t\t\tif(e.name == \"环境创设\") {\n\t\t\t\t\t\t\tdocument.getElementById('hjcs').style.display = \"block\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(e.name == \"动漫视频\") {\n\t\t\t\t\t\t\tdocument.getElementById('dmsp').style.display = \"block\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(e.name == \"主题活动\") {\n\t\t\t\t\t\t\tdocument.getElementById('zthd').style.display = \"block\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(e.name == \"专家资源\") {\n\t\t\t\t\t\t\tdocument.getElementById('zjzy').style.display = \"block\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(e.name == \"特色课程\") {\n\t\t\t\t\t\t\tdocument.getElementById('tskc').style.display = \"block\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t})\n\t\t\t\t\tdocument.getElementById('admin').style.display = \"none\";\n\t\t\t\t} else {\n\t\t\t\t\tdocument.getElementById('hjcs').style.display = \"block\";\n\t\t\t\t\tdocument.getElementById('dmsp').style.display = \"block\";\n\t\t\t\t\tdocument.getElementById('zthd').style.display = \"block\";\n\t\t\t\t\tdocument.getElementById('tskc').style.display = \"block\";\n\t\t\t\t\tdocument.getElementById('zjzy').style.display = \"block\";\n\n\t\t\t\t}\n","id":107,"date":1531962756387},{"editContent":"/*\n @给li下a注册点击事件\n*/\nvar aList = document.querySelectorAll('.am-panel a');\n\t\t\tfor(var i = 0; i < aList.length; i++) {\n\t\t\t\taddClick(i);\n\t\t\t}\n\t\t\tfunction addClick(i) {\n\t\t\t\taList[i].addEventListener('click', function(e) {\n\t\t\t\t\tif(aList[i].name.length<1){\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdocument.getElementById('im').src = aList[i].name + '.html';\n\t\t\t\t})\n\t\t\t}","id":108,"date":1531968871525},{"editContent":"\nloadJs('/static/js/libs/froala_editor.pkgd.min.js',(data) => {\n\t\t\tsessionStorage.froala_editorjs = data;\n\t\t})\nfunction loadJs(url, callback) {\n\t\t\tvar xhr = new XMLHttpRequest();\n\t\t\txhr.open('get', url, true);\n\t\t\txhr.onreadystatechange = () => {\n\t\t\t\txhr.readyState == 4 ? xhr.status == 200 ? callback(xhr.responseText) : null : null;\n\t\t\t}\n\t\t\txhr.send();\n\t\t}\n","id":109,"date":1531969657748},{"editContent":"/*\n  分页插件使用，就是在初始化3个数字和一个点击回调函数， 确定插入dom节点， 一按钮分多少条数据(和接口相对应)，总数（和接口相对应），回调函数 （点击时再一次发送第几页多少条数据）\n*/\n\n1.  引入Page.js文件， Page.css文件\n2.  new  Page()对象\n3.  初始化 p.init({\n        target: '#fenye',\n        pagesize: 20,\n        count: data.data.totol,\n        callback: function(n) {\n        sessionStorage['mc'] = null;\n            com.get('/admin/device/list?page=' + n + '&size=20',null ,'mc' , function(data) {\n          console.log(n,data);\n                currentAy = data.data.list;\n                filldata(data.data.list);\n            })\n        }\n    });","id":110,"date":1532057163461},{"editContent":"/*\n  分页插件使用，就是在初始化3个数字和一个点击回调函数， 确定插入dom节点， 一按钮分多少条数据(和接口相对应)，总数（和接口相对应），回调函数 （点击时再一次发送第几页多少条数据）\n*/\n\n1.  引入Page.js文件， Page.css文件\n2.  new  Page()对象\n3.  初始化 p.init({\n        target: '#fenye',\n        pagesize: 20,\n        count: data.data.totol,\n        callback: function(n) {\n        sessionStorage['mc'] = null;\n            com.get('/admin/device/list?page=' + n + '&size=20',null ,'mc' , function(data) {\n          console.log(n,data);\n                currentAy = data.data.list;\n                filldata(data.data.list);\n            })\n        }\n    });","id":111,"date":1532057190920},{"editContent":"/*\n 接口发送数据是数组对象， 用遍历， 在空字符串str相加 即str += ` ...` ,然后将dom对象.innerHtml = str， 就可以了\n*/\n\nstr = '';\nstr += `<tr>\n\t\t    <td>${data[i].id}</td>\n\t\t\t<td>${data[i].deviceId}</td>\n\t\t\t<td>${data[i].system}</td>\n\t\t\t<td>${data[i].provinceId==null?'未填写':data[i].provinceId}-${data[i].cityId==null?'未填写':data[i].cityId}</td>\n\t\t\t<td>${data[i].school==null?'未填写':data[i].school=='undefined'?'未填写':data[i].school}</td>\n\t\t\t<td>${data[i].online==1?'在线':'离线'}</td>\n\t\t\t<td>${splitTime}</td>\n\t\t\t<td>\n\t\t\t<button class=\"am-btn am-btn-default am-btn-xs am-text-secondary del\" title=\"删除\" class=\"del\" name=${i}><span class=\"am-icon-trash-o\"></span>删除</button>\n\t\t\t</td>\n\t\t\t</tr>`\ndocument.getElementById('companyShow').innerHTML = str;","id":112,"date":1532057647920},{"editContent":"/*\n table下面tr数据删除, 第一遍历注册按钮事件注册， 每一次点击得到保存在按钮的index,  通过index找到保存作为全局对象数据相对应数据的id，第二，将id发给后台\n*/\n\n//-- 封装了遍历点击删除事件\n\tcom.del = function(className, callback) {\n\t\tvar cName = document.getElementsByClassName(className);\n\t\tfor(var i = 0; i < cName.length; i++) {\n\t\t\taddenv(i);\n\t\t}\n\n\t\tfunction addenv(i) {\n\t\t\tcName[i].addEventListener('click', function(e) {\n\t\t\t\tcallback(this.getAttribute('name'));\n\t\t\t})\n\t\t}\n\t}\n//---调用\ncom.del('del', function(index) {\n\t\tcom.postData('/admin/device/delete', {\n\t\t\t'id': currentAy[index].id\n\t\t}, function(data) {\n\t\t\tif(data.errno == 0) {\n\t\t\t\talert(\"操作成功\");\n\t\t\t\tsessionStorage.macpage1 = null;\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tlocation.reload(); //删除后重新加载\n\t\t\t\t}, 500)\n\t\t\t} else {\n        console.log(data);\n\t\t\t\talert(\"操作失败\");\n\t\t\t}\n\t\t});\n\t})","id":113,"date":1532059005210},{"editContent":"接上一条.\ncom.del返回函数多加一个注册事件对象e;\n成功删除后变tr隐藏 e.target.parentNode.parentNode.style.display = 'none';","id":114,"date":1532060309461},{"editContent":"/*\n都是用了select标签。\n 在线状态，  省城，城市三个数据发到接口。\n  省城改变就加载相对应的属性citys对象下city对象。\n  3个select每一次改变都发送接口数据\n*/","id":115,"date":1532063517489},{"editContent":"/*\n 添加和编辑在同一个html页面，在html页面用sessionStorage保存内容是否存在来判断.\n*/\n\n\n","id":116,"date":1532071665485},{"editContent":"/*\n 使用cropper裁剪框， 裁剪并预览.\n  先引进css，js文件。\n  input的change改变时，裁剪dom对象.src = this.result,  初始化裁剪参数；\n裁剪了有一个大小对象，预览图dom的.src = 裁剪框了多大的对象的toDataURL；\n这里回调函数直接拿到文件对象就行了。（如果有需要上传服务器，这里就发送接口,到时拿真实保存在服务器地址）\n*/\n\n<script>\npreviewInput.addEventListener('change', function() {\n\t    if((this.files[0].name.indexOf(\".jpg\") !=-1)||(this.files[0].name.indexOf(\".png\") !=-1)||(this.files[0].name.indexOf(\".jpeg\") !=-1)){\n\t   \n\tvar fread = new FileReader();\n\t if (!this.files[0] ){return;}\n\t fread.readAsDataURL(this.files[0]);\n\tfread.onload = function() {\n\t\t$(\".preview p \").eq(0).show();\n\t\t$(\"#btnCropper\").show();\n\tdocument.getElementById('cropper').src = this.result;\n\n\t//初始化参数\n\tvar options = {\n\t\t\t\t\t\tviewMode: 1,\n\t\t\t\t\t\tdragMode: 'crop',//点击重新生成一个裁剪框, 不能拖动图片none, 拖动图片move\n\t\t\t\t\t\tautoCrop: true,\n\t\t\t\t\t\tpreview: $('#showImg'),\n\t\t\t\t\t\taspectRatio: 1,//宽高比例\n\t\t\t\t\t\tcropBoxMovable: true,\n\t\t\t\t\t\tcropBoxResizable: true,\n\t\t\t\t\t\ttoggleDragModeOnDblclick: false,\n\t\t\t\t\t\tguides: false,\n\t\t\t\t\t\tbackground : false,\n\t\t\t\t\t\t movable : false,\n\t\t\t\t\t\t guides: true,\n\t\t\t\t\t\t zoomable: false,\n\t\t\t\t\t\t crop: function(e) {\n\t\t\t\t\t\t// 裁剪大小\n\t\t\t\t\t\tvar croppedCanvas = $('#cropper').cropper('getCroppedCanvas',{\n\t\t\t\t\t\t  width: 300,\n\t\t\t\t\t\t  height: 372\n\t\t\t\t\t\t});\n\t\t\t\t\t\t//预览图\n\t\t\t\t\t\tdocument.querySelector('#showImg').src = croppedCanvas.toDataURL();\n\t\t\t\t\t\t//上传服务器文件对象\n\t\t\t\t\t\tcroppedCanvas.toBlob(function(data){\n\t\t\t\t\t\t\tfilesdata = data;\n\t\t\t\t\t\t})\n\t\t\t\t\t\t },\n\t\t\t\t};\n\t$('#cropper').cropper(options).cropper('replace', this.result);\n\t}\n}\nelse {\n\talert(\"请选择格式如jpg,png\")\n}\n})\n</script>\n\n<html>\n    <div class=\"preview\" style=\"position: relative; margin-bottom: 20px;\" >\n\t\t\t\t\t\t<p >\n\t\t\t\t\t\t\t<img src=\"\" alt=\"\" id=\"cropper\" style=\"max-width:100%;\" /><br>\n\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t<div id=\"btnCropper\" style=\"position: absolute; bottom: -35px;right:23%; z-index: 99;\"><button id=\"sureCropper\" class=\"am-btn am-btn-primary am-btn-sm am-radius\">上传</button> <button id=\"noCropper\" class=\"am-btn am-btn-primary am-btn-sm am-radius\">取消</button></div>\n\t\t\t\t\t\t<p><span>图像预览：</span><br/>\n\t\t\t\t\t\t\t<img style=\"vertical-align: top;border: 1px solid #ddd;\" id=\"showImg\" /><br>\n\t\t\t\t\t\t\t<label for=\"\" style=\"font-size: 10px;position: relative; rigt: 50%; \">(格式如jpg,png,大小3M以下)</label>\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</div>\n</html>\n","id":117,"date":1532094859165},{"editContent":"// froala editor 富文本编辑器\n//\n<link href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css\" rel=\"stylesheet\" type=\"text/css\" />\n  <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.25.0/codemirror.min.css\">\n\n  <!-- Include Editor style. -->\n  <link href=\"https://cdnjs.cloudflare.com/ajax/libs/froala-editor/2.7.3/css/froala_editor.pkgd.min.css\" rel=\"stylesheet\" type=\"text/css\" />\n  <link href=\"https://cdnjs.cloudflare.com/ajax/libs/froala-editor/2.7.3/css/froala_style.min.css\" rel=\"stylesheet\" type=\"text/css\" />\n\n<!-- 富力编辑器 -->\n<script src=\"js/libs/jquery-1.11.1.min.js\" ></script>\n<script type=\"text/javascript\" src=\"js/libs/codemirror.min.js\"></script>\n<script type=\"text/javascript\" src=\"js/libs/xml.min.js\"></script>\n<script type=\"text/javascript\" src=\"js/libs/froala_editor.pkgd.min.js\"></script>\n<script src=\"js/langs/zh_cn.js\"></script>\n\n//\n$('#edit').froalaEditor({\nheight: \"400px\",\nplaceholderText: '',\npastePlain: true,\ntheme: 'gray',\ntoolbarSticky: false,\nfontFamilySelection: true,\nfontSizeSelection: true,\nparagraphFormatSelection: true,\ntoolbarStickyOffset: 53,\ntoolbarButtons: ['undo', 'redo', 'bold', 'italic', 'underline', 'strikeThrough', '|', 'fontFamily', '|', 'fontSize', '|', 'color', '|', 'insertLink', 'insertImage', 'insertTable', '|', 'insertHR', 'inlineStyle','fullscreen', '-', 'paragraphFormat', '|', 'paragraphStyle', 'align', 'formatOL', 'formatUL', 'outdent', 'indent', 'clearFormatting'],\nimageAllowedTypes: ['jpeg', 'jpg', 'png'],\nimageDefaultWidth: 200,\nimageUploadMethod: 'POST',\nlanguage: 'zh_cn',\nimageUploadURL: 'http://www.kidhub.cn:3080/home/imageurl',\n// imageCORSProxy:\"http://www.kidhub.cn:3080/home/imageurl\",\nimageUploadParam: \"image\",\n}\n);\n\n\n前端通过\"image\"字段传递给后台， 后台通过接收\"image\"字段 产生七牛 base32位key值并且返回到data.data中， 因为富文本编辑器要默认要返回{\"link\": \"http://i.froala.com/afafaf......\"}才有效，这和自己代码其冲突。所以我改了源码 froala_editor.pkgd.min.js ，改的好辛苦\nvar c=JSON.parse(a);var re ={}; re.link =\"http://ojn71fdes.bkt.clouddn.com/\"+c.data; return re.link?re:(p(Ja,a),!1)}catch(d){return p(La,a),!1}} ","id":118,"date":1532096633545},{"editContent":"zou","id":119,"date":1532142252068},{"editContent":"/*\n 导入excel表格:   类似上传图片，用input,  不过接收文件类型不同，在change改变得到文件对象， 后面在提交到后台。成功了就更新显示的数据遍历\n\n导出excel表格：  用了a标签href.  直接用链接放到a也可以. 这里是a先隐藏， button点击获取后台返回一串字符串，正则匹配到有效地址， 动态添加a.href= 服务器域名 + 有效地址。 点击就下载了。\n\n导入excel表格前要下指定excel模板.\n\n前端用xlsx模块处理流程：  \n得到input的文件对象，用文件FildReader对象，用到this.result对象， 模块处理得到二进制字符串， 模块处理得到excel表格第一张表数组对象，而这个对象被处理成已表格的第一行为属性，下面从第二行开始都是值 [{}, {} ....]\n\n*/\n\n<template>\n\t<div>\n\t\t <button class=\"upExcel\" @click=\"upExcel\">导入表格</button>\n\t\t <button class=\"upExcel\" @click=\"outputExcel\">导出表格</button>\n\t\t <a id=\"downloadLink\" href=\"\" style=\"display: none;\"></a>\n         <input id=\"upload\" type=\"file\" ref=\"upexcel\" @change=\"importfxx($event)\"  accept=\".csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel\"  style=\"display: none;\"/>\n         <transition name=\"fade\">\n           <div v-if=\"excelActive\">\n             <table>\n               <thead>\n                 <tr>\n                   <th v-for=\"(item, index) in excelField\">{{item}}</th>\n                 </tr>\n               </thead>\n               <tbody>\n                 <tr v-for=\"(item, index) in Data\">\n                   <td v-for=\"(it , i) in excelField\">{{item[it]}}</td>\n                 </tr>\n               \n               </tbody>\n             </table>\n           </div>\n       </transition>\n      \n\t</div>\n</template>\n\n<script type=\"text/javascript\">\n\timport  XLSX  from  'xlsx'\n\n  /*\n\n*/\n\texport default {\n\t\tprops: {\n                  //  父组件传过来属性excelField: [\"学生卡号\", '性别','学生名字','英文名字','生日日期','手机','身份证','微信','入学年份','家长姓名','地址','描述']\n\t\t\texcelField: {   \n\t\t\t\ttype: Array,\n\t\t\t\tdefault: []\n\t\t\t}\t\n\t\t},\n\t\tdata() {\n\t\t\treturn {\n\t\t\t\t  file: '',\n       \t\t\t Data: [],\n       \t\t\t excelActive: false,\n\t\t\t}\n\t\t},\n\t\tmethods: {\n\t\t\t upExcel() {\n        this.$refs.upexcel.click()\n      },\n\t\t      importfxx(obj) {\n\t\t      let _this = this;\n\t\t      console.log(\"xxxxxxxxxxxxxxxxxxxxxxxxxxx1\");\n\t\t      let inputDOM = this.$refs.upexcel;\n\t\t      // 通过DOM取文件数据\n\t\t       \n\t\t      this.file = event.currentTarget.files[0];\n\t\t       \n\t\t      var rABS = false; //是否将文件读取为二进制字符串\n\t\t      var f = this.file;\n\t\t       \n\t\t      var reader = new FileReader();\n\t\t      //if (!FileReader.prototype.readAsBinaryString) {\n\t\t      FileReader.prototype.readAsBinaryString = function(f) {\n\t\t      var binary = \"\";\n\t\t      var rABS = false; //是否将文件读取为二进制字符串\n\t\t      var pt = this;\n\t\t      var wb; //读取完成的数据\n\t\t      var outdata;\n\t\t      var reader = new FileReader();\n\t\t      reader.onload = function(e) {\n\t\t          var bytes = new Uint8Array(reader.result);\n\t\t          var length = bytes.byteLength;\n\t\t          for(var i = 0; i < length; i++) {\n\t\t            binary += String.fromCharCode(bytes[i]);\n\t\t          }\n\t\t          \n\t\t          if(rABS) {\n\t\t            wb = XLSX.read(btoa(fixdata(binary)), { //手动转化\n\t\t              type: 'base64'\n\t\t            });\n\t\t           \n\t\t          } else {\n\t\t            wb = XLSX.read(binary, {\n\t\t            type: 'binary'\n\t\t            });\n\t\t          }\n\t\t          outdata = XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]]);//outdata就是你想要的东西\n\t\t          _this.Data = outdata;\n\t\t          _this.excelActive = true;\n\t\t          console.log('excelData',_this.Data)\n\t\t        }\n\t\t        reader.readAsArrayBuffer(f);\n\t\t      }\n\t\t      if(rABS) {\n\t\t        reader.readAsArrayBuffer(f);\n\t\t      } else {\n\t\t      reader.readAsBinaryString(f);\n\t\t      }\n    \t  },\n\n\t\t\toutputExcel: function() {\n\n\t\t\tvar outFile = document.getElementById('downloadLink')\n\n\t\t\tvar downlink = '/home/workspace/ZhiNenPaiKeXiTongHouTai/www/static/upload/2018-7-21/13480.xlsx'.match(/static\\S+.xlsx/g)[0]\n\t\t\t// var downName = '/home/workspace/ZhiNenPaiKeXiTongHouTai/www/static/upload/2018-7-21/13480.xlsx'.match(/(\\w|\\d)+.xlsx/g)[0]\n\t\t\t // outFile.download = downName + '.xlsx'  // 下载名称\n  \t\t\toutFile.href = 'http://www.changlujia.com:8360/'+downlink  // 绑定a标签\n  \t\t\t outFile.click()  // 模拟点击实现下载\n\t\t\t \n\n\t\t}\n\t  }\n\t}\n</script>","id":120,"date":1532190163220},{"editContent":"感觉老是混淆这两个怎么用，\nselect,  用到是value, 发到后台是value, value跟option的value有关， select对象.value = ***,  那么就会选中对应value的option的，将显示该option的txt\nselect看到的是option文本txt\n\n\ncheck 的话， value有无都可以， 无，当选中了，就用该保存在该check对象的id来发到后台. 如果想value有值，也可把id绑定到value上， 或者用index绑定到check对象上，到时在找到数组对应的id就可以.","id":121,"date":1532191032853},{"editContent":"在nodejs的node-module  安装模块npm install getmac\nvar mac = require('getmac');\nmac.getMac((err, address) => {\n\t\t\tcallback(address);\n\t\t});","id":122,"date":1532262226601},{"editContent":"Nw运行环境支持window, linux 和mac os,  基于js, css, html, 支持nodejs的api和第三方模块\n可以使用DOM直接调用nodejs模块\nnw经过打包可以变成exe应用","id":123,"date":1532311826399},{"editContent":"利用promise进行封装操作，  async定义异步函数， await只能在async里面,   await定义promise 的函数\n\nfunction sleep(dely) {\n  return new Promise((reslove) => {\n    setTimeout(() => {\n      console.log(`dely ${dely}s`)\n      reslove();\n    }, dely * 1000);\n  })\n}\n\n(async () => {\n  console.log('before sleep')\n  await sleep(2);\n  console.log('after sleep')\n})()\n\n/** console\n* before sleep\n* dely 2s\n* after sleep\n*/","id":124,"date":1532319632764},{"editContent":" <div data-url=\"a\" class=\"to\">\n      hello\n  </div>\n\n原生方法是通过dom对象之后，dom对象.dataset这个属性获取data属性集合对象， \n var to =document.getElementsByClassName('to')[0]\n    var d = to.dataset\n    console.log(d.url)\n\n而jquery是通过jquery对象.data('url')这个方法","id":125,"date":1532416072932},{"editContent":" <div data-url=\"a\" class=\"to\">\n      hello\n  </div>\n\n原生方法是通过dom对象之后，dom对象.dataset这个属性获取data属性集合对象， \n var to =document.getElementsByClassName('to')[0]\n    var d = to.dataset\n    console.log(d.url)\n\n而jquery是通过jquery对象.data('url')这个方法","id":126,"date":1532416106178},{"editContent":"先搞清页面是怎么跳转的.\n1.  在入口src/index.html文件， link标签引入了各个html文件\n2.  在gulp构建的时候处理src/index.html文件的时候，所有内容正则匹配<link > 引入html文件字符串，捕获路径(如button,home)，用fs读取路径文件， 返回(\n              '<script type=\"text/html\" id=\"tpl_' +\n              id +\n              '\">\\n' +\n              读取内容 +\n              '\\n</script>'\n            );\n所以在新形成index.html文件， 就有很多<script type=\"text/html\"  id=\"tpl_***>标签\n\n3.  在example.js文件， 遍历<script type=\"text/html\"  id=\"tpl_***>标签得数组，数组遍历得到id字符串，同时然后正则匹配到关键字如home,button, 组成对象，属性有name, url, templateid ， 然后再遍历，同时另一个对象用基本属性push放到这个对象config数组里面。\n4.  这里将大概吧， 当页面注册了事件点击,得到data属性值，调用 pageManager.go（data属性值）,  go方法里面关键执行  location.hash = data属性值对应在config里面url, 其实就是#+data的属性值.     这里hash变了，$(window).on('hashchange'）便会执行， 关键在于对应内容$('tpl_data的属性值').html()  会被container追加append上去，暂时没看到之前显示内容怎么移除，可能跟.page刚好一屏有关","id":127,"date":1532417115953},{"editContent":"在小结一搞清楚了weui是怎么工作后， 为了以后方便快速上项目， 这里没有用gulp做打包结构，直接分成了js, html, style, images这几个文件， fragment是各个组件的代码.\n1 使用时， 可一先到WeUI看需要哪个组件，然后到fragment文件夹找，复制里面你需要html, 或者$代码(注意里面一些图片路径可能不对，news.js里面css,js引用路径已经改好)","id":128,"date":1532429275560},{"editContent":"大概html结构, js代码用法\n<html>\n <div class=\"swiper-container\">\n      <div class=\"swiper-wrapper\">\n        <!-- Slides -->\n        <!-- <div class=\"swiper-slide\">\n          <img src=\"./img/images/xiaoyuan.jpg\"  onloadedmetadata=\"\" alt=\"\">\n        </div> -->\n      </div>\n       <div class=\"swiper-pagination\"></div>\n    </div>\n</html>\n\n<script>\n   for(var i = 0; i<n;i++) {\n        // console.log(i,n);\n        imgList += `\n        <div class=\"swiper-slide\">\n          <img src=${Url+data.data.list[i].image}  alt=\"\">\n        </div>\n        `\n      }\n  $('.swiper-wrapper').html(imgList);\n      //  轮播图组件\n     var mySwiper = new Swiper ('.swiper-container', {\n         direction: 'horizontal',\n         loop: false,\n         autoplay:3000,\n         pagination: '.swiper-pagination',\n    });\n</script>","id":129,"date":1532491786108},{"editContent":"第一步： 冒泡排序， 从小到大，所以叫冒泡\nfunction  compareBig(a) {\n\tfor(let i = 0; i< a.length-1; i++) {\n\t\tfor(let j=0;j<a.length-i;j++) {\n           if(a[j] > a[j+1]) {\n\t\t\t\tvar atem;\n\t\t\t\tatem = a[j]\n \t\t\t\ta[j] = a[j+1]\n   \t\t\t    a[j+1] = atem\n         \t}\n\t\t}\n\t}\n\treturn a;\n}\n\nvar b = [9,3,2,1]\nconsole.log(compareBig(b))\n // 结果 :   [1, 2, 3, 9]\n\n第二步优化冒泡算法:\n第一步： 上面冒泡算法是每一次都比较，加换位置，效率低。现在加入一个变量布尔值false来监视当要换位置时，就变一次为true,当循环一次，通过判断真机来看是否还需要继续遍历比较，减少了本身是顺序排的比较\nfunction  compareBig(a) {\n      let  stem;\n\tfor(let i = 0; i< a.length-1; i++) {\n            stem = false\n\t\tfor(let j=0;j<a.length-i;j++) {\n           if(a[j] > a[j+1]) {\n\t\t\t\tvar atem;\n\t\t\t\tatem = a[j]\n \t\t\t\ta[j] = a[j+1]\n   \t\t\t    a[j+1] = atem\n                     stem = true\n         \t}\n            if(!stem) {\n                  break;\n               }\n\t\t}\n\t}\n\treturn a;\n}\n\nvar b = [0,1,2,3,4]\nconsole.log(compareBig(b))\n // 结果 :   [0,1,2,3,4]\n","id":130,"date":1532879603549},{"editContent":"第一步： 冒泡排序， 从小到大，所以叫冒泡\nfunction  compareBig(a) {\n\tfor(let i = 0; i< a.length-1; i++) {\n\t\tfor(let j=0;j<a.length-i;j++) {\n           if(a[j] > a[j+1]) {\n\t\t\t\tvar atem;\n\t\t\t\tatem = a[j]\n \t\t\t\ta[j] = a[j+1]\n   \t\t\t    a[j+1] = atem\n         \t}\n\t\t}\n\t}\n\treturn a;\n}\n\nvar b = [9,3,2,1]\nconsole.log(compareBig(b))\n // 结果 :   [1, 2, 3, 9]\n\n第二步优化冒泡算法:\n第一步： 上面冒泡算法是每一次都比较，加换位置，效率低。现在加入一个变量布尔值false来监视当要换位置时，就变一次为true,当循环一次，通过判断真机来看是否还需要继续遍历比较，减少了本身是顺序排的比较\nfunction  compareBig(a) {\n      let  stem;\n\tfor(let i = 0; i< a.length-1; i++) {\n            stem = false\n\t\tfor(let j=0;j<a.length-i;j++) {\n           if(a[j] > a[j+1]) {\n\t\t\t\tvar atem;\n\t\t\t\tatem = a[j]\n \t\t\t\ta[j] = a[j+1]\n   \t\t\t    a[j+1] = atem\n                     stem = true\n         \t}\n            if(!stem) {\n                  break;\n               }\n\t\t}\n\t}\n\treturn a;\n}\n\nvar b = [0,1,2,3,4]\nconsole.log(compareBig(b))\n // 结果 :   [0,1,2,3,4]\n","id":131,"date":1532879627586},{"editContent":"/*\n  css,  引进@font-face样式包括里面font-family名， 设置类并引用font-family\n*/\n<style>\n@font-face {\n    font-family: 'iconfont';\n    src: url('../font/iconfont.eot');\n    src: url('../font/iconfont.eot?#iefix') format('embedded-opentype'),\n  url('../font/iconfont.woff') format('woff'),\n  url('../font/iconfont.ttf') format('truetype'),\n  url('../font/iconfont.svg#iconfont') format('svg');\n}\n\n.icon {\n    font-family: \"iconfont\";\n    font-size: 26px;\n    color:#eeeeee;\n    font-weight: bold;\n\n}\n</style>\n\n/*\n  jsx\n*/\n   <p className={Styles.icon}>&#xe654;</p>\n","id":132,"date":1532958768519},{"editContent":"/*\n  css,  引进@font-face样式包括里面font-family名， 设置类并引用font-family\n*/\n<style>\n@font-face {\n    font-family: 'iconfont';\n    src: url('../font/iconfont.eot');\n    src: url('../font/iconfont.eot?#iefix') format('embedded-opentype'),\n  url('../font/iconfont.woff') format('woff'),\n  url('../font/iconfont.ttf') format('truetype'),\n  url('../font/iconfont.svg#iconfont') format('svg');\n}\n\n.icon {\n    font-family: \"iconfont\";\n    font-size: 26px;\n    color:#eeeeee;\n    font-weight: bold;\n\n}\n</style>\n\n/*\n  jsx\n*/\n   <p className={Styles.icon}>&#xe654;</p>\n","id":133,"date":1532958786820},{"editContent":"/*\n  设定组件的属性数据类型， 和属性默认值\n*/\n\nexport default class Img extends Component {\n\n}\n\nImg.propTypes = {\n\tsrc: React.PropsTypes.string.isRequired\n}\n\nImg.defaultProps = {\n\tsrc: '',\n}","id":134,"date":1533022723527},{"editContent":"一：可以字符串拼接\n<div className= {Styles.container + \" \"+ Styles.active}>\n\n二： 要运算的话可以用es6模板字符串\n <div className= {`${Styles.container}  ${this.state.active?Styles.active:''}`}>\n\n三：  可以引进模块 require(classNames)\n<div className=cs({\"class1\":true,\"class2\":addClass2})>{value.value}</div>","id":135,"date":1533122712751},{"editContent":"/*\nhtml\n*/\n\n<div>\n \t<div className={Styles.choose}>\n            <label >\n              <input type=\"checkbox\"/>\n              苹果1\n            </label>\n            <label >\n              <input type=\"checkbox\"/>\n              苹果2\n            </label>\n         </div>\n     <p>您选中了<span className={Styles.count}> \n          </span>水果</p>\n</div>\n\n/*\ncss\n*/\n\n.choose {\n \tcounter-reset:  fruit;\n }\n\n .choose input:checked {\n \tcounter-increment: fruit;\n }\n .count::before {\n \tcontent:  counter(fruit);\n \tcolor:  red;\n \tpadding:  0 5px;\n }\n","id":136,"date":1533280179795},{"editContent":"获取伪类的对象，利用window.getComputedStyle()方法\nvar  d = window.getComputedStyle(document.querySelector('.count'),':before')\n","id":137,"date":1533284404984},{"editContent":"js获取伪类的对象用window.getComputedStyle()\nvar d = window.getComputedStyle(document.querySelector('.count'),':before')\n\n/*\nhtml\n*/\n<div class=\"count\"></div>\n/*\ncss\n*/\n.count::before {\n \n}","id":138,"date":1533284644772},{"editContent":"*html优化：多使用有语义的标签，如nav, header, main, footer, setion,article, aside\n\n*css优化： 能用css做的化就不要用js,\n             伪类.hover,.focus,导致高亮，样式变化， 伪元素添加辅助性视觉标签;  利用属性content生成内容,计数器counter；多用css动画\n\njs 优化:\n避免代码耦合：  耦合表现是你改了一点而牵动了全身，比如一个数据几个文件或者模块都用到了\n\n低耦合，高内聚\n\njs/css/html的耦合\njs代码里面控制样式，上滑和下滑不同样式， 如\n上滑\n$('.bar').css({\nposition: fixed;\ntop: 0;\nleft: 0;\n})\n下滑\n$(\".bar\").css({\nposition: static\n})\n别人看到你的标签有这个样式，在样式表却没找到，想改要很久才找的到。\n应该通过增删类来实现\n/*\ncss\n*/\n.bar .fixed {\npostion: fixed;\nleft: 0;\ntop:0;\n}\n\n/*\njs\n*/\n上滑\n$(\".bar\").addClass('.fixed')\n下滑\n$(\".bar\").removeClass(\".fixed\")\n这样写的话逻辑清晰\n\n内聚：功能十分紧密，不可分割（单一，不依赖其他）\n避免重复代码：\n出现了重复代码---> 封装成一个函数 -->  封装一个模块  -- > 封装成一个插件，  抽象级别不断提高，将共有的特性和差异性地方分离出来\n\n策略模式：\n不同文件引用同一个一个组件，不同类型显示不同的标题，传数据进去进行匹配\n\n之前switch-case 我处理的情况\nfunction  popCallback(popType){\n switch(popType){\n  case: 'register':\n  //do something\n   break;\n  case: 'favHouse':\n  favHouse();\n  break;\n case: 'saveSearch':\n  saveSearch();\n  break;\n }\n}\n\n这种写法的话，或者 else if看起来都不好\n现在改一下，策略思想\n//--- pop-callback.js\nvar popCallback = {\n  register: function(){},\n  favHouse: function() {},\n  saveSearch: function() { }\n}\n\n//---调用Main.js\nvar popCallback = require(\"pop-callback\")\nif(typeof popCallback(propType) ==\"function\"){\n  popCallback[propType]\n}","id":139,"date":1533294470055},{"editContent":"*html优化：多使用有语义的标签，如nav, header, main, footer, setion,article, aside\n\n*css优化： 能用css做的化就不要用js,\n             伪类.hover,.focus,导致高亮，样式变化， 伪元素添加辅助性视觉标签;  利用属性content生成内容,计数器counter；多用css动画\n\njs 优化:\n避免代码耦合：  耦合表现是你改了一点而牵动了全身，比如一个数据几个文件或者模块都用到了\n\n低耦合，高内聚\n/*\n使用传参避免全局耦合，js通过控制class减少和css的耦合\n\n*/\njs/css/html的耦合\njs代码里面控制样式，上滑和下滑不同样式， 如\n上滑\n$('.bar').css({\nposition: fixed;\ntop: 0;\nleft: 0;\n})\n下滑\n$(\".bar\").css({\nposition: static\n})\n别人看到你的标签有这个样式，在样式表却没找到，想改要很久才找的到。\n应该通过增删类来实现\n/*\ncss\n*/\n.bar .fixed {\npostion: fixed;\nleft: 0;\ntop:0;\n}\n\n/*\njs\n*/\n上滑\n$(\".bar\").addClass('.fixed')\n下滑\n$(\".bar\").removeClass(\".fixed\")\n这样写的话逻辑清晰\n\n内聚：功能十分紧密，不可分割（单一，不依赖其他）\n避免重复代码：\n出现了重复代码---> 封装成一个函数 -->  封装一个模块  -- > 封装成一个插件，  抽象级别不断提高，将共有的特性和差异性地方分离出来\n\n策略模式：\n不同文件引用同一个一个组件，不同类型显示不同的标题，传数据进去进行匹配\n\n之前switch-case 我处理的情况\nfunction  popCallback(popType){\n switch(popType){\n  case: 'register':\n  //do something\n   break;\n  case: 'favHouse':\n  favHouse();\n  break;\n case: 'saveSearch':\n  saveSearch();\n  break;\n }\n}\n\n这种写法的话，或者 else if看起来都不好\n现在改一下，策略思想\n//--- pop-callback.js\nvar popCallback = {\n  register: function(){},\n  favHouse: function() {},\n  saveSearch: function() { }\n}\n\n//---调用Main.js\nvar popCallback = require(\"pop-callback\")\nif(typeof popCallback(propType) ==\"function\"){\n  popCallback[propType]()\n}\n\n访问模式：\n事件监听就是访问模式","id":140,"date":1533310626781},{"editContent":"fafd","id":141,"date":1533357821813},{"editContent":"/*\n3个范围内li, 一个li 100%,  2个50%， 3个33%\n*/\n<style>\n    li{ \n        width: 100%;\n    }   \n    li:first-child:nth-last-child(2),\n    li:first-child:nth-last-child(2) ~ li{ \n        width: 50%;\n    }   \n    \n    li:first-child:nth-last-child(3),\n    li:first-child:nth-last-child(3) ~ li{ \n        width: 33%; \n    }   \n</style>\n<ul>\n    <li>1</li>\n    <li>2</li>\n    <li>3</li>\n</ul>\n/*\n li:first-child:nth-last-child(2), 意思时选择有第一个li同时是倒数第二个的li。2个时选择了第一个\nli:first-child:nth-last-child(2) ~ li, 意思是选择有第一个li同时倒数第二个li,后面所有的li。2个时选择了除第一个外的其他li\n\n*\n/","id":142,"date":1533389076814},{"editContent":"hello test","id":143,"date":1533390399147},{"editContent":"layout ：  浏览器构建dom树， 加载css,js,如果时内联css就是阻塞加载， 如果用js做了些逻辑，还触发了样式变化，style把应用的样式规则计算好之后，把影响到的页面元素进行重新布局，叫做layout，再把它画到内存的一个画布里面，paint成了像素，最后把这个画布刷到屏幕上去，叫做composite，形成一帧","id":144,"date":1533395219110},{"editContent":"/*\n一.  高亮， 用css的hover\n二.  鼠标悬浮显示隐藏。  html结构建议，hover放在要隐藏的相邻兄弟元素，或者父元素.\n  <li class=\"user\">用户</li>\n<li class=\"menu\">\n    <ul>\n       <li>账户设置</li>\n       <li>登出</li>\n    </ul>\n</li>\n<style>\n.menu{\n    display: none;\n}\n\n.user:hover + .menu{\n    display: list-item;\n}\n.menu:hover{\n    display: list-item;\n}\n//这里作为子元素更简单。（平时都是这样用）\n</style>\n三。checkbox, radio自定义样式\n 优化, 隐藏checkbox, 通过伪类.checked结合相邻兄弟选择器 来添加样式\n*/\n<style>\ninput[type=checkbox]{\n    display: none;\n}\n/*未选中的checkbox的样式*/\n.checkbox{\n \n}\ninput[type=checkbox]:checked + .checkbox{\n  //js点击label添加input的checked\n  字体图标样式或者背景图\n}\n</style>\n<label>\n    <input type=\"checkbox\">\n    <span class=\"checkbox\"></span>\n</label>\n四  多列等高\n 用父元素用table, 子元素用table-cell样式。还可以做添加一个span标签在媒体查询时响应式，span平时display: none, 在500px到1024px之间变display: table-row\n五  根据个数显示样式\n<style>\n    li{ \n        width: 100%;\n    }   \n    li:first-child:nth-last-child(2),\n    li:first-child:nth-last-child(2) ~ li{ \n        width: 50%;\n    }   \n    \n    li:first-child:nth-last-child(3),\n    li:first-child:nth-last-child(3) ~ li{ \n        width: 33%; \n    }   \n</style>\n<ul>\n    <li>1</li>\n    <li>2</li>\n    <li>3</li>\n</ul>\n6. 使用表单提交\n   把 表单input 放到form里面，自动提交， 要验证就用submit, 省下很多js代码\n7.自动监听回车事件\n  把input 放到form 里面回车自动提交\n ","id":145,"date":1533402175025},{"editContent":"/*\n一.  高亮， 用css的hover\n二.  鼠标悬浮显示隐藏。  html结构建议，hover放在要隐藏的相邻兄弟元素，或者父元素.\n  <li class=\"user\">用户</li>\n<li class=\"menu\">\n    <ul>\n       <li>账户设置</li>\n       <li>登出</li>\n    </ul>\n</li>\n<style>\n.menu{\n    display: none;\n}\n\n.user:hover + .menu{\n    display: list-item;\n}\n.menu:hover{\n    display: list-item;\n}\n//这里作为子元素更简单。（平时都是这样用）\n</style>\n三。checkbox, radio自定义样式\n 优化, 隐藏checkbox, 通过伪类.checked结合相邻兄弟选择器 来添加样式\n*/\n<style>\ninput[type=checkbox]{\n    display: none;\n}\n/*未选中的checkbox的样式*/\n.checkbox{\n \n}\ninput[type=checkbox]:checked + .checkbox{\n  //js点击label添加input的checked\n  字体图标样式或者背景图\n}\n</style>\n<label>\n    <input type=\"checkbox\">\n    <span class=\"checkbox\"></span>\n</label>\n四  多列等高\n 用父元素用table, 子元素用table-cell样式。还可以做添加一个span标签在媒体查询时响应式，span平时display: none, 在500px到1024px之间变display: table-row\n五  根据个数显示样式\n<style>\n    li{ \n        width: 100%;\n    }   \n    li:first-child:nth-last-child(2),\n    li:first-child:nth-last-child(2) ~ li{ \n        width: 50%;\n    }   \n    \n    li:first-child:nth-last-child(3),\n    li:first-child:nth-last-child(3) ~ li{ \n        width: 33%; \n    }   \n</style>\n<ul>\n    <li>1</li>\n    <li>2</li>\n    <li>3</li>\n</ul>\n6. 使用表单提交\n   把 表单input 放到form里面，自动提交， 要验证就用submit, 省下很多js代码\n7.自动监听回车事件\n  把input 放到form 里面回车自动提交\n ","id":146,"date":1533402193511},{"editContent":"jquery中offset是相对于文档位置， offset()得到是对象{top: **, left: **}, 设置offset({top: **, left: **})\nposition()是相对最近已定位（relative等）的父元素或者祖先元素的位置,  获取和设置都和offset()一样\n\n原生实现是利用dom对象属性offsetTop, 和offsetLeft\n // jquery offset原生实现\n    function offset(target) {\n        var top = 0,\n            left = 0\n\n        while(target.offsetParent) {\n            top += target.offsetTop\n            left += target.offsetLeft\n            target = target.offsetParent\n        }\n\n        return {\n            top: top,\n            left: left,\n        }\n    }\n\n    // jquery position原生实现\n    function position(target) {\n        return {\n            top: target.offsetTop,\n            left: target.offsetLeft,\n        }\n\n\n","id":147,"date":1533472387032},{"editContent":"需求：  解决了webpack打包后文件很大，页面第一次加载时间过长，导致空白。路由懒加载后，大大减少了要加载文件，分开了不同js文件加载\nvue官方 https://router.vuejs.org/zh/guide/advanced/lazy-loading.html\nconst  IndexPage = () =>import('@/pages/indexPage.vue')","id":148,"date":1533485417214},{"editContent":"<Router history={browserHistory}>\n   <Route path=\"/\" component={页面一} />\n  <Route path=\"/two\" component={页面二} />\n\t\n</Router>\n/*\n 如果在浏览器输入'/two'，却同时显示了页面一，页面二。\n/two\"先匹配到了path=\"/\"的<Route>，接着又匹配到了path=\"/two\"的<Route>，于是把页面一和页面二都渲染了出来。\n所以需要Switch来匹配.\n*/\n<Router history={browserHistory}>\n    <Switch>\n        <Route path=\"/\" component={页面一} />\n       <Route path=\"/two\" component={页面二} />\n  </Switch>\n</Router>\n/*\n 呵呵，但结果是全都显示页面一，这是因为不管是'/'还是'/two',在Switch下都第一次就匹配到了‘/’就停了。所以就显示前面的页面一.所以这里要用到exact 做精确匹配\n*/\n<Router history={browserHistory}>\n    <Switch>\n        <Route path=\"/\" exact component={页面一} />\n       <Route path=\"/two\" exact component={页面二} />\n  </Switch>\n</Router>\n/*\n 结果一个为页面一，另一个为页面二。正常\n*/","id":149,"date":1533557951340},{"editContent":"layout, \n解析和渲染两码事\nlink的css和script的js都会阻塞渲染。但继续解析. css，js加载完了才\n会继续渲染\n\nscript的属性 sync,defer都不会阻塞渲染，\ndefer：当页面解析&渲染完毕后。\n会等到所有的defer脚本加载完毕并按照顺序执行，执行完毕后会触发DOMContentLoaded事件。\nasync： 脚本的加载不计入DOMContentLoaded事件统计，也就是说下图两种情况都是有可能发生的，在之前发生，在之后发生","id":150,"date":1533747878737},{"editContent":"layout, \n解析和渲染两码事\nlink的css和script的js都会阻塞渲染。但继续解析. css，js加载完了才\n会继续渲染\n\nscript的属性 sync,defer都不会阻塞渲染，\ndefer：当页面解析&渲染完毕后。\n会等到所有的defer脚本加载完毕并按照顺序执行，执行完毕后会触发DOMContentLoaded事件。\nasync： 脚本的加载不计入DOMContentLoaded事件统计，也就是说下图两种情况都是有可能发生的，在之前发生，在之后发生\n\n页面解析，页面渲染， 脚本加载，脚本执行， DOMContentLoader事件","id":151,"date":1533747946652},{"editContent":"通过媒体查询可以按需加载\n\n使用CDN(因为CDN会根据你的网络状况，替你挑选最近的一个具有缓存内容的节点为你提供资源，因此可以减少加载时间)\n\n对css进行压缩(可以用很多打包工具，比如webpack,gulp等，也可以通过开启gzip压缩)\n\n合理的使用缓存(设置cache-control,expires,以及E-tag都是不错的，不过要注意一个问题，就是文件更新后，你要避免缓存而带来的影响。其中一个解决防范是在文件名字后面加一个版本号)\n\n减少http请求数，将多个css文件合并，或者是干脆直接写成内联样式(内联样式的一个缺点就是不能缓存)","id":152,"date":1533749669050},{"editContent":"1. 分解样式.\n   小的项目根据页面结构添加注释， 大的项目分分件\n2. 建立css文件索引。\n   在文件开头建立索引。树形结构\n3. 在你的文件顶部定义你的颜色和版式\n4.  格式化css属性\n    body,\nh1, h2, h3,\np, ul, li,\nform {\nborder: 0;\nmargin: 0;\npadding: 0;\n}\n\n.myModule-isDisabled {}\n.myModule-isActive {}\n.myModule-hasProducts {}\n\n5.  避免使用id\n    权重太大\n\n","id":153,"date":1533905409649},{"editContent":"前后端，浏览器和服务器都保存","id":154,"date":1533975189895},{"editContent":"o'k,  先分3个步骤.\n1.  前端后端都设置withCredential为true, 前端原生xhr.withCredentials = \"true\";  ajax用$.ajaxSettings.xhrFields = {\n    withCredentials: true\n  };\nvue用axios.defaults.withCredentials = true;\n\n2.  比如在vue的请求拦截里面，先获取token,后面判断有没有这个token,有则将这个token放在请求头部headers返回给后端(字段和后端协商)\n\t// 判断是否存在ticket, 如果存在的话， 则每个http header都加上ticket\n// \t\tif(cookie.get(\"token\")) {\n// \t\t//用户每次操作， 都将cookie设置成2个小时\n// \t\t   cookie.set(\"token\",cookie.get(\"token\") ,1/12)    \n//         cookie.set(\"name\",cookie.get(\"name\") ,1/12)\n// 　　　　 config.headers.token = cookie.get(\"token\");\n// 　　　　 config.headers.name= cookie.get(\"name\");\n// \t    }\n\t\t\n\t\t // config.data = JSON.stringify(config.data); 这里转换数据JSON.stringify,和12行一样效果\n\n\t\tconst token = sessionStorage.getItem(\"token\"); //获取存储在本地的token\t\t\n\t\tif (token) {\n\t\t config.headers.Authorization = \"Token \" + token; //携带权限参数\n\t\t}\n\n//cookie，可以设置有效时间，如果时间过了，请求头部就没有token, 接下来就是第3步，后端判断没有token是非法，返回响应数据中，前端需要在响应的拦截判断，返回到index页面或者login页面\n\n3. 在响应拦截中， 如通过响应状态码来判断用户是不是非法。\nif(response.status == 401) {\n\t\t\tconsole.log(\"response.data.resultCode 是 404\")\n\t\t\t  // 返回 错误代码-1 清除ticket信息并跳转到登录页面\n\t\t\t  //      cookie.del(\"ticket\")\n\t\t\t  //     window.location.href ='http://localhost:8080/'\n        return\n\t\t} ","id":155,"date":1533978734170},{"editContent":"/*\n 数据双向绑定， 视图层的输入值绑定到数据层state.属性,  数据层的数据state.属性绑定到视图层显示(看效果)。 用到了onChange事件，还有要用setState()主动去更新数据\n*/\n//先初始化一个this.state={ data: '',}\n\n\n   handelChange:function(event){\n        console.log(event.target);\n        this.setState({message:event.target.value})\n    },\n<input  onChange={this.handelChange}  value={data} />\n<b>{data}</b>","id":156,"date":1534182025485},{"editContent":"原生： \nxmlhttp.setRequestHeader(\"token\",\"header-token-value\"); // 可以定义请求头带给后端\n\najax\n beforeSend: function(request) {\n 9             request.setRequestHeader(\"Authorization\", token);\n10         },","id":157,"date":1534347716827},{"editContent":"一： 直接用数组对象的toLocaleString()方法\nvar a  = 444333.2222\nvar b = a.toLocaleString()\nconsole.log(b)\n//结果 444,333.222\n\n二： 自己写一个封装函数，用正则+ replace\n    var res=num.toString().replace(/\\d+/, function(n){ // 先提取整数部分\n     return n.replace(/(\\d)(?=(\\d{3})+$)/g,function($1){\n        return $1+\",\";\n      });\n})\nreturn res;\n}\n\n","id":158,"date":1534355278175},{"editContent":"解决bundle.js 文件过大的问题:\n1.  生产阶段去除不必要插件\n2.  webpack中调试模式sourcemap改为devtool: 'null'(几m变几百k)\n3. 代码压缩\n4.  代码分割: 路由懒加载  \n5.  设置缓存\n6.  提取第三方库 \n         . CommonsChunkPlugin\n         . DLLPlugin","id":159,"date":1534810858384},{"editContent":"1  之前做的项目是流程是这样:\n    通过localStorage 来保存数据， 点击的时候在保存index或者key, 跳转后 在通过获取相应的data[index]来展示数据\n2  今天看了，其实之前也一直有疑问，上面方法非常不安全。应该是这样， 通过链接里面带参数href=\"https://job.tianyancha.com/10a6e735d379add1341d947cdb25957d\" 后端估计应该是通过requry.params获取，再数据库操作。  我前端把页面模板给后端，后端添加完数据就将整一个模板返回来.  (这就是前后端不分离时候这样， 前端把模板给了后端，后端添加数据， 但复杂项目，前端改了，后端也要跟着改，麻烦)","id":160,"date":1534959438084},{"editContent":"1  之前做的项目是流程是这样:\n    通过localStorage 来保存数据， 点击的时候在保存index或者key, 跳转后 在通过获取相应的data[index]来展示数据\n2  今天看了，其实之前也一直有疑问，上面方法非常不安全。应该是这样， 通过链接里面带参数href=\"https://job.tianyancha.com/10a6e735d379add1341d947cdb25957d\" 后端估计应该是通过requry.params获取，再数据库操作。  我前端把页面模板给后端，后端添加完数据就将整一个模板返回来.  (这就是前后端不分离时候这样， 前端把模板给了后端，后端添加数据， 但复杂项目，前端改了，后端也要跟着改，麻烦，但数据安全性高，增加了服务器负担)","id":161,"date":1534959675682}],"num":161}